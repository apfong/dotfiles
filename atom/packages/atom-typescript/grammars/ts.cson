
# This file is generated by "scripts/grammar.ts"
# Last generated: Wed, 11 Oct 2017 22:02:06 GMT

name: "TypeScript"
scopeName: "source.ts"
fileTypes: [
  "ts"
]
uuid: "ef98eb90-bf9b-11e4-bb52-0800200c9a66"
patterns: [
  {
    include: "#directives"
  }
  {
    include: "#statements"
  }
  {
    name: "comment.line.shebang.ts"
    match: "\\A(#!).*(?=$)"
    captures:
      "1":
        name: "punctuation.definition.comment.ts"
  }
]
repository:
  statements:
    patterns: [
      {
        comment: "Match full triple slash reference comments"
        match: "(\\/\\/\\/\\s*<reference\\s*path\\s*=)(.*?)(\\s*\\/>)"
        captures:
          "1":
            name: "keyword.other.ts"
          "2":
            name: "reference.path.string.quoted"
          "3":
            name: "keyword.other.ts"
      }
      {
        comment: "Match <amd-dependency"
        match: "(\\/\\/\\/\\s*<amd-dependency\\s*path\\s*=)(.*)(\\/>)"
        captures:
          "1":
            name: "keyword.other.ts"
          "2":
            name: "amd.path.string.quoted"
          "3":
            name: "keyword.other.ts"
      }
      {
        comment: "Match <amd-module"
        match: "(\\/\\/\\/\\s*<amd-module\\s*name\\s*=)(.*)(\\/>)"
        captures:
          "1":
            name: "keyword.other.ts"
          "2":
            name: "amd.path.string.quoted"
          "3":
            name: "keyword.other.ts"
      }
      {
        include: "#string"
      }
      {
        include: "#template"
      }
      {
        include: "#comment"
      }
      {
        include: "#declaration"
      }
      {
        include: "#control-statement"
      }
      {
        include: "#after-operator-block-as-object-literal"
      }
      {
        include: "#decl-block"
      }
      {
        include: "#expression"
      }
      {
        include: "#punctuation-semicolon"
      }
    ]
  declaration:
    patterns: [
      {
        include: "#decorator"
      }
      {
        include: "#var-expr"
      }
      {
        include: "#function-declaration"
      }
      {
        include: "#class-declaration"
      }
      {
        include: "#interface-declaration"
      }
      {
        include: "#enum-declaration"
      }
      {
        include: "#namespace-declaration"
      }
      {
        include: "#type-alias-declaration"
      }
      {
        include: "#import-equals-declaration"
      }
      {
        include: "#import-declaration"
      }
      {
        include: "#export-declaration"
      }
    ]
  "control-statement":
    patterns: [
      {
        include: "#switch-statement"
      }
      {
        include: "#for-loop"
      }
      {
        name: "keyword.control.trycatch.ts"
        match: "(?<!\\.|\\$)\\b(catch|finally|throw|try)\\b(?!\\$|\\.)"
      }
      {
        name: "keyword.control.loop.ts"
        match: "(?<!\\.|\\$)\\b(break|continue|do|goto|while)\\b(?!\\$|\\.)"
      }
      {
        name: "keyword.control.flow.ts"
        match: "(?<!\\.|\\$)\\b(return)\\b(?!\\$|\\.)"
      }
      {
        name: "keyword.control.switch.ts"
        match: "(?<!\\.|\\$)\\b(case|default|switch)\\b(?!\\$|\\.)"
      }
      {
        name: "keyword.control.conditional.ts"
        match: "(?<!\\.|\\$)\\b(else|if)\\b(?!\\$|\\.)"
      }
      {
        name: "keyword.control.with.ts"
        match: "(?<!\\.|\\$)\\b(with)\\b(?!\\$|\\.)"
      }
      {
        name: "keyword.other.debugger.ts"
        match: "(?<!\\.|\\$)\\b(debugger)\\b(?!\\$|\\.)"
      }
      {
        name: "storage.modifier.ts"
        match: "(?<!\\.|\\$)\\b(declare)\\b(?!\\$|\\.)"
      }
    ]
  expression:
    patterns: [
      {
        include: "#string"
      }
      {
        include: "#regex"
      }
      {
        include: "#template"
      }
      {
        include: "#comment"
      }
      {
        include: "#function-expression"
      }
      {
        include: "#class-expression"
      }
      {
        include: "#arrow-function"
      }
      {
        include: "#cast"
      }
      {
        include: "#ternary-expression"
      }
      {
        include: "#new-expr"
      }
      {
        include: "#object-literal"
      }
      {
        include: "#expression-operators"
      }
      {
        include: "#function-call"
      }
      {
        include: "#literal"
      }
      {
        include: "#support-objects"
      }
      {
        include: "#identifiers"
      }
      {
        include: "#paren-expression"
      }
      {
        include: "#punctuation-comma"
      }
      {
        include: "#punctuation-accessor"
      }
    ]
  decorator:
    name: "meta.decorator.ts"
    begin: "(?<!\\.|\\$)\\@"
    beginCaptures:
      "0":
        name: "punctuation.decorator.ts"
    end: "(?=\\s)"
    patterns: [
      {
        include: "#expression"
      }
    ]
  "var-expr":
    name: "meta.var.expr.ts"
    begin: "(?<!\\.|\\$)(?:(\\bexport)\\s+)?\\b(var|let|const(?!\\s+enum\\b))\\b(?!\\$|\\.)"
    beginCaptures:
      "1":
        name: "keyword.control.export.ts"
      "2":
        name: "storage.type.ts"
    end: "(?=$|^|;|}|(\\s+(of|in)\\s+))"
    patterns: [
      {
        include: "#destructuring-variable"
      }
      {
        include: "#var-single-variable"
      }
      {
        include: "#variable-initializer"
      }
      {
        include: "#comment"
      }
      {
        begin: "(,)\\s*(?!\\S)"
        beginCaptures:
          "1":
            name: "punctuation.separator.comma.ts"
        end: "(?<!,)((?==|;|}|(\\s+(of|in)\\s+)|^\\s*$))|((?<=\\S)(?=\\s*$))"
        patterns: [
          {
            include: "#comment"
          }
          {
            include: "#destructuring-variable"
          }
          {
            include: "#var-single-variable"
          }
          {
            include: "#punctuation-comma"
          }
        ]
      }
      {
        include: "#punctuation-comma"
      }
    ]
  "var-single-variable":
    patterns: [
      {
        name: "meta.var-single-variable.expr.ts"
        begin: '''
          (?x)([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*
          # function assignment |
          (=\\s*(
            ((async\\s+)?(
              (function\\s*[(<*]) |
              (function\\s+) |
              ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)
            )) |
            ((async\\s*)?(
              # sure shot arrow functions even if => is on new line
          (
            [(]\\s*
            (
              ([)]\\s*:) |                                                                 # ():
              ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                            # [(]param: | [(]...param:
            )
          ) |
          (
            [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                        # < typeparam extends
          ) |
          # arrow function possible to detect only with => on same line
          (
            (<\\s*[_$[:alpha:]\\{\\(\\[]([^<>=]|=[^<]|\\<\\s*[_$[:alpha:]\\{\\(\\[]([^=<>]|=[^<])+\\>)+>\\s*)?                                                           # typeparameters
            \\((\\s*[_$[:alpha:]\\{\\(]([^()]|\\((\\s*[_$[:alpha:]\\{\\(]\\{\\(][^()]*)?\\))*)?\\)    # parameteres
            (\\s*:\\s*([^<>\\(\\)]|\\<[^<>]+\\>|\\([^\\(\\)]+\\))+)?                                # return type
            \\s*=>                                                                         # arrow operator
          )
            ))
          )) |
          # typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>
          (:\\s*(
            (<) |
            ([(]\\s*(
              ([)]) |
              (\\.\\.\\.) |
              ([_$[:alnum:]]+\\s*(
                ([:,?=])|
                ([)]\\s*=>)
              ))
            ))
          )))
        '''
        beginCaptures:
          "1":
            name: "meta.definition.variable.ts entity.name.function.ts"
        end: "(?=$|^|[;,=}]|(\\s+(of|in)\\s+))"
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      }
      {
        name: "meta.var-single-variable.expr.ts"
        begin: "([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])"
        beginCaptures:
          "1":
            name: "meta.definition.variable.ts variable.other.constant.ts"
        end: "(?=$|^|[;,=}]|(\\s+(of|in)\\s+))"
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      }
      {
        name: "meta.var-single-variable.expr.ts"
        begin: "([_$[:alpha:]][_$[:alnum:]]*)"
        beginCaptures:
          "1":
            name: "meta.definition.variable.ts variable.other.readwrite.ts"
        end: "(?=$|^|[;,=}]|(\\s+(of|in)\\s+))"
        patterns: [
          {
            include: "#var-single-variable-type-annotation"
          }
        ]
      }
    ]
  "var-single-variable-type-annotation":
    patterns: [
      {
        include: "#type-annotation"
      }
      {
        include: "#string"
      }
      {
        include: "#comment"
      }
    ]
  "destructuring-variable":
    patterns: [
      {
        name: "meta.object-binding-pattern-variable.ts"
        begin: "(?<!=|:|of|in)\\s*(?=\\{)"
        end: "(?=$|^|[;,=}]|(\\s+(of|in)\\s+))"
        patterns: [
          {
            include: "#object-binding-pattern"
          }
          {
            include: "#type-annotation"
          }
          {
            include: "#comment"
          }
        ]
      }
      {
        name: "meta.array-binding-pattern-variable.ts"
        begin: "(?<!=|:|of|in)\\s*(?=\\[)"
        end: "(?=$|^|[;,=}]|(\\s+(of|in)\\s+))"
        patterns: [
          {
            include: "#array-binding-pattern"
          }
          {
            include: "#type-annotation"
          }
          {
            include: "#comment"
          }
        ]
      }
    ]
  "object-binding-element":
    patterns: [
      {
        include: "#comment"
      }
      {
        begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\\\'|\\\\)*\\')|(\\\"([^\\\"\\\\]|\\\\\\\"|\\\\)*\\\")|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))"
        end: "(?=,|\\})"
        patterns: [
          {
            include: "#object-binding-element-propertyName"
          }
          {
            include: "#binding-element"
          }
        ]
      }
      {
        include: "#object-binding-pattern"
      }
      {
        include: "#destructuring-variable-rest"
      }
      {
        include: "#variable-initializer"
      }
      {
        include: "#punctuation-comma"
      }
    ]
  "object-binding-element-propertyName":
    begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\\\'|\\\\)*\\')|(\\\"([^\\\"\\\\]|\\\\\\\"|\\\\)*\\\")|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))"
    end: "(:)"
    endCaptures:
      "0":
        name: "punctuation.destructuring.ts"
    patterns: [
      {
        include: "#string"
      }
      {
        include: "#array-literal"
      }
      {
        name: "variable.object.property.ts"
        match: "([_$[:alpha:]][_$[:alnum:]]*)"
      }
    ]
  "binding-element":
    patterns: [
      {
        include: "#comment"
      }
      {
        include: "#object-binding-pattern"
      }
      {
        include: "#array-binding-pattern"
      }
      {
        include: "#destructuring-variable-rest"
      }
      {
        include: "#variable-initializer"
      }
    ]
  "destructuring-variable-rest":
    match: "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)"
    captures:
      "1":
        name: "keyword.operator.rest.ts"
      "2":
        name: "meta.definition.variable.ts variable.other.readwrite.ts"
  "object-binding-pattern":
    begin: "(?:(\\.\\.\\.)\\s*)?(\\{)"
    beginCaptures:
      "1":
        name: "keyword.operator.rest.ts"
      "2":
        name: "punctuation.definition.binding-pattern.object.ts"
    end: "\\}"
    endCaptures:
      "0":
        name: "punctuation.definition.binding-pattern.object.ts"
    patterns: [
      {
        include: "#object-binding-element"
      }
    ]
  "array-binding-pattern":
    begin: "(?:(\\.\\.\\.)\\s*)?(\\[)"
    beginCaptures:
      "1":
        name: "keyword.operator.rest.ts"
      "2":
        name: "punctuation.definition.binding-pattern.array.ts"
    end: "\\]"
    endCaptures:
      "0":
        name: "punctuation.definition.binding-pattern.array.ts"
    patterns: [
      {
        include: "#binding-element"
      }
      {
        include: "#punctuation-comma"
      }
    ]
  "parameter-name":
    patterns: [
      {
        match: "\\s*\\b(public|protected|private|readonly)(?=\\s+(public|protected|private|readonly)\\s+)"
        captures:
          "1":
            name: "storage.modifier.ts"
      }
      {
        match: '''
          (?x)(?:\\s*\\b(public|private|protected|readonly)\\s+)?(\\.\\.\\.)?\\s*(?<!=|:)(?:(this)|([_$[:alpha:]][_$[:alnum:]]*))\\s*(\\??)(?=\\s*
          # function assignment |
          (=\\s*(
            ((async\\s+)?(
              (function\\s*[(<*]) |
              (function\\s+) |
              ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)
            )) |
            ((async\\s*)?(
              # sure shot arrow functions even if => is on new line
          (
            [(]\\s*
            (
              ([)]\\s*:) |                                                                 # ():
              ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                            # [(]param: | [(]...param:
            )
          ) |
          (
            [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                        # < typeparam extends
          ) |
          # arrow function possible to detect only with => on same line
          (
            (<\\s*[_$[:alpha:]\\{\\(\\[]([^<>=]|=[^<]|\\<\\s*[_$[:alpha:]\\{\\(\\[]([^=<>]|=[^<])+\\>)+>\\s*)?                                                           # typeparameters
            \\((\\s*[_$[:alpha:]\\{\\(]([^()]|\\((\\s*[_$[:alpha:]\\{\\(]\\{\\(][^()]*)?\\))*)?\\)    # parameteres
            (\\s*:\\s*([^<>\\(\\)]|\\<[^<>]+\\>|\\([^\\(\\)]+\\))+)?                                # return type
            \\s*=>                                                                         # arrow operator
          )
            ))
          )) |
          # typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>
          (:\\s*(
            (<) |
            ([(]\\s*(
              ([)]) |
              (\\.\\.\\.) |
              ([_$[:alnum:]]+\\s*(
                ([:,?=])|
                ([)]\\s*=>)
              ))
            ))
          )))
        '''
        captures:
          "1":
            name: "storage.modifier.ts"
          "2":
            name: "keyword.operator.rest.ts"
          "3":
            name: "entity.name.function.ts variable.language.this.ts"
          "4":
            name: "entity.name.function.ts"
          "5":
            name: "keyword.operator.optional.ts"
      }
      {
        match: "(?:\\s*\\b(public|private|protected|readonly)\\s+)?(\\.\\.\\.)?\\s*(?<!=|:)(?:((?<!\\.|\\$)\\bthis\\b(?!\\.|\\$))|([_$[:alpha:]][_$[:alnum:]]*))\\s*(\\??)"
        captures:
          "1":
            name: "storage.modifier.ts"
          "2":
            name: "keyword.operator.rest.ts"
          "3":
            name: "variable.parameter.ts variable.language.this.ts"
          "4":
            name: "variable.parameter.ts"
          "5":
            name: "keyword.operator.optional.ts"
      }
    ]
  "destructuring-parameter":
    patterns: [
      {
        name: "meta.parameter.object-binding-pattern.ts"
        begin: "(?<!=|:)\\s*(\\{)"
        beginCaptures:
          "1":
            name: "punctuation.definition.binding-pattern.object.ts"
        end: "\\}"
        endCaptures:
          "0":
            name: "punctuation.definition.binding-pattern.object.ts"
        patterns: [
          {
            include: "#parameter-object-binding-element"
          }
        ]
      }
      {
        name: "meta.paramter.array-binding-pattern.ts"
        begin: "(?<!=|:)\\s*(\\[)"
        beginCaptures:
          "1":
            name: "punctuation.definition.binding-pattern.array.ts"
        end: "\\]"
        endCaptures:
          "0":
            name: "punctuation.definition.binding-pattern.array.ts"
        patterns: [
          {
            include: "#parameter-binding-element"
          }
          {
            include: "#punctuation-comma"
          }
        ]
      }
    ]
  "parameter-object-binding-element":
    patterns: [
      {
        include: "#comment"
      }
      {
        begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\\\'|\\\\)*\\')|(\\\"([^\\\"\\\\]|\\\\\\\"|\\\\)*\\\")|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(:))"
        end: "(?=,|\\})"
        patterns: [
          {
            include: "#object-binding-element-propertyName"
          }
          {
            include: "#parameter-binding-element"
          }
        ]
      }
      {
        include: "#parameter-object-binding-pattern"
      }
      {
        include: "#destructuring-parameter-rest"
      }
      {
        include: "#variable-initializer"
      }
      {
        include: "#punctuation-comma"
      }
    ]
  "parameter-binding-element":
    patterns: [
      {
        include: "#comment"
      }
      {
        include: "#parameter-object-binding-pattern"
      }
      {
        include: "#parameter-array-binding-pattern"
      }
      {
        include: "#destructuring-parameter-rest"
      }
      {
        include: "#variable-initializer"
      }
    ]
  "destructuring-parameter-rest":
    match: "(?:(\\.\\.\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)"
    captures:
      "1":
        name: "keyword.operator.rest.ts"
      "2":
        name: "variable.parameter.ts"
  "parameter-object-binding-pattern":
    begin: "(?:(\\.\\.\\.)\\s*)?(\\{)"
    beginCaptures:
      "1":
        name: "keyword.operator.rest.ts"
      "2":
        name: "punctuation.definition.binding-pattern.object.ts"
    end: "\\}"
    endCaptures:
      "0":
        name: "punctuation.definition.binding-pattern.object.ts"
    patterns: [
      {
        include: "#parameter-object-binding-element"
      }
    ]
  "parameter-array-binding-pattern":
    begin: "(?:(\\.\\.\\.)\\s*)?(\\[)"
    beginCaptures:
      "1":
        name: "keyword.operator.rest.ts"
      "2":
        name: "punctuation.definition.binding-pattern.array.ts"
    end: "\\]"
    endCaptures:
      "0":
        name: "punctuation.definition.binding-pattern.array.ts"
    patterns: [
      {
        include: "#parameter-binding-element"
      }
      {
        include: "#punctuation-comma"
      }
    ]
  "field-declaration":
    name: "meta.field.declaration.ts"
    begin: "(?<!\\()(?:(?<!\\.|\\$)\\b(readonly)\\s+)?(?=(([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\\\'|\\\\)*\\')|(\\\"([^\\\"\\\\]|\\\\\\\"|\\\\)*\\\")|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\?\\s*)?(=|:))"
    beginCaptures:
      "1":
        name: "storage.modifier.ts"
    end: "(?=\\}|;|,|$|(^(?!(([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\\\'|\\\\)*\\')|(\\\"([^\\\"\\\\]|\\\\\\\"|\\\\)*\\\")|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\?\\s*)?(=|:))))|(?<=\\})"
    patterns: [
      {
        include: "#variable-initializer"
      }
      {
        begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\\\'|\\\\)*\\')|(\\\"([^\\\"\\\\]|\\\\\\\"|\\\\)*\\\")|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\?\\s*)?(=|:))"
        end: "(?=[};,=]|$|(^(?!(([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\\\'|\\\\)*\\')|(\\\"([^\\\"\\\\]|\\\\\\\"|\\\\)*\\\")|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\?\\s*)?(=|:))))|(?<=\\})"
        patterns: [
          {
            include: "#type-annotation"
          }
          {
            include: "#string"
          }
          {
            include: "#array-literal"
          }
          {
            include: "#comment"
          }
          {
            name: "meta.definition.property.ts entity.name.function.ts"
            match: '''
              (?x)([_$[:alpha:]][_$[:alnum:]]*)(?=(\\?\\s*)?\\s*
              # function assignment |
              (=\\s*(
                ((async\\s+)?(
                  (function\\s*[(<*]) |
                  (function\\s+) |
                  ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)
                )) |
                ((async\\s*)?(
                  # sure shot arrow functions even if => is on new line
              (
                [(]\\s*
                (
                  ([)]\\s*:) |                                                                 # ():
                  ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                            # [(]param: | [(]...param:
                )
              ) |
              (
                [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                        # < typeparam extends
              ) |
              # arrow function possible to detect only with => on same line
              (
                (<\\s*[_$[:alpha:]\\{\\(\\[]([^<>=]|=[^<]|\\<\\s*[_$[:alpha:]\\{\\(\\[]([^=<>]|=[^<])+\\>)+>\\s*)?                                                           # typeparameters
                \\((\\s*[_$[:alpha:]\\{\\(]([^()]|\\((\\s*[_$[:alpha:]\\{\\(]\\{\\(][^()]*)?\\))*)?\\)    # parameteres
                (\\s*:\\s*([^<>\\(\\)]|\\<[^<>]+\\>|\\([^\\(\\)]+\\))+)?                                # return type
                \\s*=>                                                                         # arrow operator
              )
                ))
              )) |
              # typeannotation is fn type: < | () | (... | (param: | (param, | (param? | (param= | (param) =>
              (:\\s*(
                (<) |
                ([(]\\s*(
                  ([)]) |
                  (\\.\\.\\.) |
                  ([_$[:alnum:]]+\\s*(
                    ([:,?=])|
                    ([)]\\s*=>)
                  ))
                ))
              )))
            '''
          }
          {
            name: "meta.definition.property.ts variable.object.property.ts"
            match: "[_$[:alpha:]][_$[:alnum:]]*"
          }
          {
            name: "keyword.operator.optional.ts"
            match: "\\?"
          }
        ]
      }
    ]
  "variable-initializer":
    patterns: [
      {
        begin: "(?<!=|!)(=)(?!=)(?=\\s*\\S)"
        beginCaptures:
          "1":
            name: "keyword.operator.assignment.ts"
        end: "(?=$|^|[,);}\\]])"
        patterns: [
          {
            include: "#expression"
          }
        ]
      }
      {
        begin: "(?<!=|!)(=)(?!=)"
        beginCaptures:
          "1":
            name: "keyword.operator.assignment.ts"
        end: "(?=[,);}\\]])|(?=^\\s*$)|(?<=\\S)(?<!=)(?=\\s*$)"
        patterns: [
          {
            include: "#expression"
          }
        ]
      }
    ]
  "function-declaration":
    name: "meta.function.ts"
    begin: "(?<!\\.|\\$)\\b(?:(export)\\s+)?(?:(async)\\s+)?(function\\b)(?:\\s*(\\*))?(?:(?:\\s+|(?<=\\*))([_$[:alpha:]][_$[:alnum:]]*))?\\s*"
    beginCaptures:
      "1":
        name: "keyword.control.export.ts"
      "2":
        name: "storage.modifier.async.ts"
      "3":
        name: "storage.type.function.ts"
      "4":
        name: "keyword.generator.asterisk.ts"
      "5":
        name: "meta.definition.function.ts entity.name.function.ts"
    end: "(?=$|^|;)|(?<=\\})"
    patterns: [
      {
        include: "#function-body"
      }
    ]
  "function-expression":
    name: "meta.function.expression.ts"
    begin: "(?<!\\.|\\$)\\b(?:(async)\\s+)?(function\\b)(?:\\s*(\\*))?(?:(?:\\s+|(?<=\\*))([_$[:alpha:]][_$[:alnum:]]*))?\\s*"
    beginCaptures:
      "1":
        name: "storage.modifier.async.ts"
      "2":
        name: "storage.type.function.ts"
      "3":
        name: "keyword.generator.asterisk.ts"
      "4":
        name: "meta.definition.function.ts entity.name.function.ts"
    end: "(?<=\\})"
    patterns: [
      {
        include: "#function-body"
      }
    ]
  "function-body":
    patterns: [
      {
        include: "#comment"
      }
      {
        include: "#type-parameters"
      }
      {
        include: "#function-parameters"
      }
      {
        include: "#return-type"
      }
      {
        include: "#decl-block"
      }
    ]
  "method-declaration":
    patterns: [
      {
        name: "meta.method.declaration.ts"
        begin: "(?<!\\.|\\$)(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)(?:(\\*)\\s*)?(?=((([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\\\'|\\\\)*\\')|(\\\"([^\\\"\\\\]|\\\\\\\"|\\\\)*\\\")|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*[\\(\\<])"
        beginCaptures:
          "1":
            name: "storage.modifier.ts"
          "2":
            name: "storage.modifier.ts"
          "3":
            name: "storage.modifier.async.ts"
          "4":
            name: "storage.type.property.ts"
          "5":
            name: "keyword.generator.asterisk.ts"
        end: "(?=\\}|;|,|$)|(?<=\\})"
        patterns: [
          {
            include: "#method-declaration-name"
          }
          {
            include: "#function-body"
          }
        ]
      }
      {
        name: "meta.method.declaration.ts"
        begin: "(?<!\\.|\\$)(?:\\b(public|private|protected)\\s+)?(?:\\b(abstract)\\s+)?(?:\\b(async)\\s+)?(?:(?:\\b(?:(new)|(constructor))\\b(?!\\$|\\.|:))|(?:(\\*)\\s*)?(?=((([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\\\'|\\\\)*\\')|(\\\"([^\\\"\\\\]|\\\\\\\"|\\\\)*\\\")|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))?\\s*[\\(\\<]))"
        beginCaptures:
          "1":
            name: "storage.modifier.ts"
          "2":
            name: "storage.modifier.ts"
          "3":
            name: "storage.modifier.async.ts"
          "4":
            name: "keyword.operator.new.ts"
          "5":
            name: "storage.type.ts"
          "6":
            name: "keyword.generator.asterisk.ts"
        end: "(?=\\}|;|,|$)|(?<=\\})"
        patterns: [
          {
            include: "#method-declaration-name"
          }
          {
            include: "#function-body"
          }
        ]
      }
    ]
  "object-literal-method-declaration":
    name: "meta.method.declaration.ts"
    begin: "(?<!\\.|\\$)(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=((([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\\\'|\\\\)*\\')|(\\\"([^\\\"\\\\]|\\\\\\\"|\\\\)*\\\")|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*[\\(\\<])"
    beginCaptures:
      "1":
        name: "storage.modifier.async.ts"
      "2":
        name: "storage.type.property.ts"
      "3":
        name: "keyword.generator.asterisk.ts"
    end: "(?=\\}|;|,)|(?<=\\})"
    patterns: [
      {
        include: "#method-declaration-name"
      }
      {
        include: "#function-body"
      }
      {
        begin: "(?<!\\.|\\$)(?:\\b(async)\\s+)?(?:\\b(get|set)\\s+)?(?:(\\*)\\s*)?(?=((([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\\\'|\\\\)*\\')|(\\\"([^\\\"\\\\]|\\\\\\\"|\\\\)*\\\")|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??))\\s*[\\(\\<])"
        beginCaptures:
          "1":
            name: "storage.modifier.async.ts"
          "2":
            name: "storage.type.property.ts"
          "3":
            name: "keyword.generator.asterisk.ts"
        end: "(?=\\(|\\<)"
        patterns: [
          {
            include: "#method-declaration-name"
          }
        ]
      }
    ]
  "method-declaration-name":
    begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*)|(\\'([^\\'\\\\]|\\\\\\'|\\\\)*\\')|(\\\"([^\\\"\\\\]|\\\\\\\"|\\\\)*\\\")|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\]))\\s*(\\??)\\s*[\\(\\<])"
    end: "(?=\\(|\\<)"
    patterns: [
      {
        include: "#string"
      }
      {
        include: "#array-literal"
      }
      {
        name: "meta.definition.method.ts entity.name.function.ts"
        match: "[_$[:alpha:]][_$[:alnum:]]*"
      }
      {
        name: "keyword.operator.optional.ts"
        match: "\\?"
      }
    ]
  "arrow-function":
    patterns: [
      {
        name: "meta.arrow.ts"
        match: "(?:(?<!\\.|\\$)(\\basync)\\s+)?([_$[:alpha:]][_$[:alnum:]]*)\\s*(?==>)"
        captures:
          "1":
            name: "storage.modifier.async.ts"
          "2":
            name: "variable.parameter.ts"
      }
      {
        name: "meta.arrow.ts"
        begin: '''
          (?x) (?:
            (?<!\\.|\\$)(\\basync)
          )? ((?<![})!\\]])\\s*
            (?=
              # sure shot arrow functions even if => is on new line
          (
            [(]\\s*
            (
              ([)]\\s*:) |                                                                 # ():
              ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                            # [(]param: | [(]...param:
            )
          ) |
          (
            [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                        # < typeparam extends
          ) |
          # arrow function possible to detect only with => on same line
          (
            (<\\s*[_$[:alpha:]\\{\\(\\[]([^<>=]|=[^<]|\\<\\s*[_$[:alpha:]\\{\\(\\[]([^=<>]|=[^<])+\\>)+>\\s*)?                                                           # typeparameters
            \\((\\s*[_$[:alpha:]\\{\\(]([^()]|\\((\\s*[_$[:alpha:]\\{\\(]\\{\\(][^()]*)?\\))*)?\\)    # parameteres
            (\\s*:\\s*([^<>\\(\\)]|\\<[^<>]+\\>|\\([^\\(\\)]+\\))+)?                                # return type
            \\s*=>                                                                         # arrow operator
          )
            )
          )
        '''
        beginCaptures:
          "1":
            name: "storage.modifier.async.ts"
        end: "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|const|import|enum|namespace|module|type|abstract|declare)\\s+))"
        patterns: [
          {
            include: "#comment"
          }
          {
            include: "#type-parameters"
          }
          {
            include: "#function-parameters"
          }
          {
            include: "#arrow-return-type"
          }
        ]
      }
      {
        name: "meta.arrow.ts"
        begin: "=>"
        beginCaptures:
          "0":
            name: "storage.type.function.arrow.ts"
        end: "(?<=\\}|\\S)(?<!=>)|((?!\\{)(?=\\S))"
        patterns: [
          {
            include: "#decl-block"
          }
          {
            include: "#expression"
          }
        ]
      }
    ]
  "indexer-declaration":
    name: "meta.indexer.declaration.ts"
    begin: "(?:(?<!\\.|\\$)\\b(readonly)\\s*)?(\\[)\\s*([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=:)"
    beginCaptures:
      "1":
        name: "storage.modifier.ts"
      "2":
        name: "meta.brace.square.ts"
      "3":
        name: "variable.parameter.ts"
    end: "(\\])\\s*(\\?\\s*)?|$"
    endCaptures:
      "1":
        name: "meta.brace.square.ts"
      "2":
        name: "keyword.operator.optional.ts"
    patterns: [
      {
        include: "#type-annotation"
      }
    ]
  "indexer-mapped-type-declaration":
    name: "meta.indexer.mappedtype.declaration.ts"
    begin: "(?:(?<!\\.|\\$)\\b(readonly)\\s*)?(\\[)\\s*([_$[:alpha:]][_$[:alnum:]]*)\\s+(in)\\s+"
    beginCaptures:
      "1":
        name: "storage.modifier.ts"
      "2":
        name: "meta.brace.square.ts"
      "3":
        name: "entity.name.type.ts"
      "4":
        name: "keyword.operator.expression.in.ts"
    end: "(\\])\\s*(\\?\\s*)?|$"
    endCaptures:
      "1":
        name: "meta.brace.square.ts"
      "2":
        name: "keyword.operator.optional.ts"
    patterns: [
      {
        include: "#type"
      }
    ]
  "function-parameters":
    name: "meta.parameters.ts"
    begin: "\\("
    beginCaptures:
      "0":
        name: "punctuation.definition.parameters.begin.ts"
    end: "\\)"
    endCaptures:
      "0":
        name: "punctuation.definition.parameters.end.ts"
    patterns: [
      {
        include: "#comment"
      }
      {
        include: "#decorator"
      }
      {
        include: "#destructuring-parameter"
      }
      {
        include: "#parameter-name"
      }
      {
        include: "#type-annotation"
      }
      {
        include: "#variable-initializer"
      }
      {
        name: "punctuation.separator.parameter.ts"
        match: ","
      }
    ]
  "class-declaration":
    name: "meta.class.ts"
    begin: "(?<!\\.|\\$)\\b(?:(export)\\s+)?\\b(?:(abstract)\\s+)?\\b(class)\\b(?=\\s+|/[/*])"
    beginCaptures:
      "1":
        name: "keyword.control.export.ts"
      "2":
        name: "storage.modifier.ts"
      "3":
        name: "storage.type.class.ts"
    end: "(?<=\\})"
    patterns: [
      {
        include: "#class-declaration-or-expression-patterns"
      }
    ]
  "class-expression":
    name: "meta.class.ts"
    begin: "(?<!\\.|\\$)\\b(class)\\b(?=\\s+|[<{]|/[/*])"
    beginCaptures:
      "1":
        name: "storage.type.class.ts"
    end: "(?<=\\})"
    patterns: [
      {
        include: "#class-declaration-or-expression-patterns"
      }
    ]
  "class-declaration-or-expression-patterns":
    patterns: [
      {
        include: "#comment"
      }
      {
        include: "#class-or-interface-heritage"
      }
      {
        match: "[_$[:alpha:]][_$[:alnum:]]*"
        captures:
          "0":
            name: "entity.name.type.class.ts"
      }
      {
        include: "#type-parameters"
      }
      {
        include: "#class-or-interface-body"
      }
    ]
  "interface-declaration":
    name: "meta.interface.ts"
    begin: "(?<!\\.|\\$)\\b(?:(export)\\s+)?\\b(?:(abstract)\\s+)?\\b(interface)\\b(?=\\s+|/[/*])"
    beginCaptures:
      "1":
        name: "keyword.control.export.ts"
      "2":
        name: "storage.modifier.ts"
      "3":
        name: "storage.type.interface.ts"
    end: "(?<=\\})"
    patterns: [
      {
        include: "#comment"
      }
      {
        include: "#class-or-interface-heritage"
      }
      {
        match: "[_$[:alpha:]][_$[:alnum:]]*"
        captures:
          "0":
            name: "entity.name.type.interface.ts"
      }
      {
        include: "#type-parameters"
      }
      {
        include: "#class-or-interface-body"
      }
    ]
  "class-or-interface-heritage":
    begin: "(?<!\\.|\\$)(?:\\b(extends|implements)\\b)(?!\\$|\\.)"
    beginCaptures:
      "1":
        name: "storage.modifier.ts"
    end: "(?=\\{)"
    endCaptures:
      "1":
        name: "punctuation.definition.block.ts"
    patterns: [
      {
        include: "#comment"
      }
      {
        include: "#class-or-interface-heritage"
      }
      {
        include: "#type-parameters"
      }
      {
        match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(\\.)(?=\\s*[_$[:alpha:]][_$[:alnum:]]*(\\s*\\.\\s*[_$[:alpha:]][_$[:alnum:]]*)*\\s*([,<{]|extends|implements|//|/\\*))"
        captures:
          "1":
            name: "entity.name.type.module.ts"
          "2":
            name: "punctuation.accessor.ts"
      }
      {
        match: "([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*([,<{]|extends|implements|//|/\\*))"
        captures:
          "1":
            name: "entity.other.inherited-class.ts"
      }
      {
        include: "#expression"
      }
    ]
  "class-or-interface-body":
    begin: "\\{"
    beginCaptures:
      "0":
        name: "punctuation.definition.block.ts"
    end: "\\}"
    endCaptures:
      "0":
        name: "punctuation.definition.block.ts"
    patterns: [
      {
        include: "#string"
      }
      {
        include: "#comment"
      }
      {
        include: "#decorator"
      }
      {
        include: "#method-declaration"
      }
      {
        include: "#indexer-declaration"
      }
      {
        include: "#field-declaration"
      }
      {
        include: "#type-annotation"
      }
      {
        include: "#variable-initializer"
      }
      {
        include: "#access-modifier"
      }
      {
        include: "#property-accessor"
      }
      {
        include: "#after-operator-block-as-object-literal"
      }
      {
        include: "#decl-block"
      }
      {
        include: "#expression"
      }
      {
        include: "#punctuation-comma"
      }
      {
        include: "#punctuation-semicolon"
      }
    ]
  "access-modifier":
    name: "storage.modifier.ts"
    match: "(?<!\\.|\\$)\\b(abstract|public|protected|private|readonly|static)\\b(?!\\$|\\.)"
  "property-accessor":
    name: "storage.type.property.ts"
    match: "(?<!\\.|\\$)\\b(get|set)\\b(?!\\$|\\.)"
  "enum-declaration":
    name: "meta.enum.declaration.ts"
    begin: "(?<!\\.|\\$)(?:(\\bexport)\\s+)?(?:\\b(const)\\s+)?\\b(enum)\\s+([_$[:alpha:]][_$[:alnum:]]*)"
    beginCaptures:
      "1":
        name: "keyword.control.export.ts"
      "2":
        name: "storage.modifier.ts"
      "3":
        name: "storage.type.enum.ts"
      "4":
        name: "entity.name.type.enum.ts"
    end: "(?<=\\})"
    patterns: [
      {
        include: "#comment"
      }
      {
        begin: "\\{"
        beginCaptures:
          "0":
            name: "punctuation.definition.block.ts"
        end: "\\}"
        endCaptures:
          "0":
            name: "punctuation.definition.block.ts"
        patterns: [
          {
            include: "#comment"
          }
          {
            begin: "([_$[:alpha:]][_$[:alnum:]]*)"
            beginCaptures:
              "0":
                name: "variable.other.enummember.ts"
            end: "(?=,|\\}|$)"
            patterns: [
              {
                include: "#comment"
              }
              {
                include: "#variable-initializer"
              }
            ]
          }
          {
            begin: "(?=((\\'([^\\'\\\\]|\\\\\\'|\\\\)*\\')|(\\\"([^\\\"\\\\]|\\\\\\\"|\\\\)*\\\")|(\\[([^\\[\\]]|\\[[^\\[\\]]*\\])+\\])))"
            end: "(?=,|\\}|$)"
            patterns: [
              {
                include: "#string"
              }
              {
                include: "#array-literal"
              }
              {
                include: "#comment"
              }
              {
                include: "#variable-initializer"
              }
            ]
          }
          {
            include: "#punctuation-comma"
          }
        ]
      }
    ]
  "namespace-declaration":
    name: "meta.namespace.declaration.ts"
    begin: "(?<!\\.|\\$)(?:(\\bexport)\\s+)?\\b(namespace|module)\\s+(?=[_$[:alpha:]\"'`])"
    beginCaptures:
      "1":
        name: "keyword.control.export.ts"
      "2":
        name: "storage.type.namespace.ts"
    end: "(?<=\\})|(?=;|\\babstract\\b|\\basync\\b|\\bclass\\b|\\bconst\\b|\\bdeclare\\b|\\benum\\b|\\bexport\\b|\\bfunction\\b|\\bimport\\b|\\binterface\\b|\\blet\\b|\\bmodule\\b|\\bnamespace\\b|\\btype\\b|\\bvar\\b)"
    patterns: [
      {
        include: "#comment"
      }
      {
        include: "#string"
      }
      {
        name: "entity.name.type.module.ts"
        match: "([_$[:alpha:]][_$[:alnum:]]*)"
      }
      {
        include: "#punctuation-accessor"
      }
      {
        include: "#decl-block"
      }
    ]
  "type-alias-declaration":
    name: "meta.type.declaration.ts"
    begin: "(?<!\\.|\\$)(?:(\\bexport)\\s+)?\\b(type)\\b\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*"
    beginCaptures:
      "1":
        name: "keyword.control.export.ts"
      "2":
        name: "storage.type.type.ts"
      "3":
        name: "entity.name.type.alias.ts"
    end: "(?=[};]|\\babstract\\b|\\basync\\b|\\bclass\\b|\\bconst\\b|\\bdeclare\\b|\\benum\\b|\\bexport\\b|\\bfunction\\b|\\bimport\\b|\\binterface\\b|\\blet\\b|\\bmodule\\b|\\bnamespace\\b|\\btype\\b|\\bvar\\b)"
    patterns: [
      {
        include: "#comment"
      }
      {
        include: "#type-parameters"
      }
      {
        include: "#type"
      }
      {
        match: "(=)\\s*"
        captures:
          "1":
            name: "keyword.operator.assignment.ts"
      }
    ]
  "import-equals-declaration":
    patterns: [
      {
        name: "meta.import-equals.external.ts"
        begin: "(?<!\\.|\\$)(?:(\\bexport)\\s+)?\\b(import)\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*(=)\\s*(require)\\s*(\\()"
        beginCaptures:
          "1":
            name: "keyword.control.export.ts"
          "2":
            name: "keyword.control.import.ts"
          "3":
            name: "variable.other.readwrite.alias.ts"
          "4":
            name: "keyword.operator.assignment.ts"
          "5":
            name: "keyword.control.require.ts"
          "6":
            name: "meta.brace.round.ts"
        end: "\\)"
        endCaptures:
          "0":
            name: "meta.brace.round.ts"
        patterns: [
          {
            include: "#comment"
          }
          {
            include: "#string"
          }
        ]
      }
      {
        name: "meta.import-equals.internal.ts"
        begin: "(?<!\\.|\\$)(?:(\\bexport)\\s+)?\\b(import)\\s+([_$[:alpha:]][_$[:alnum:]]*)\\s*(=)\\s*(?!require\\b)"
        beginCaptures:
          "1":
            name: "keyword.control.export.ts"
          "2":
            name: "keyword.control.import.ts"
          "3":
            name: "variable.other.readwrite.alias.ts"
          "4":
            name: "keyword.operator.assignment.ts"
        end: "(?=;|$|^)"
        patterns: [
          {
            include: "#comment"
          }
          {
            match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(\\.)"
            captures:
              "1":
                name: "entity.name.type.module.ts"
              "2":
                name: "punctuation.accessor.ts"
          }
          {
            name: "variable.other.readwrite.ts"
            match: "([_$[:alpha:]][_$[:alnum:]]*)"
          }
        ]
      }
    ]
  "import-declaration":
    name: "meta.import.ts"
    begin: "(?<!\\.|\\$)(?:(\\bexport)\\s+)?\\b(import)(?!(\\s*[:\\(])|(\\$|\\.))\\b"
    beginCaptures:
      "1":
        name: "keyword.control.export.ts"
      "2":
        name: "keyword.control.import.ts"
    end: "(?=;|$|^)"
    patterns: [
      {
        include: "#import-export-declaration"
      }
    ]
  "export-declaration":
    patterns: [
      {
        match: "(?<!\\.|\\$)\\b(export)\\s+(as)\\s+(namespace)\\s+([_$[:alpha:]][_$[:alnum:]]*)"
        captures:
          "1":
            name: "keyword.control.export.ts"
          "2":
            name: "keyword.control.as.ts"
          "3":
            name: "storage.type.namespace.ts"
          "4":
            name: "entity.name.type.module.ts"
      }
      {
        name: "meta.export.default.ts"
        begin: "(?<!\\.|\\$)\\b(export)(?:(?:\\s*(=))|(?:\\s+(default)(?=\\s+)))"
        beginCaptures:
          "1":
            name: "keyword.control.export.ts"
          "2":
            name: "keyword.operator.assignment.ts"
          "3":
            name: "keyword.control.default.ts"
        end: "(?=;|$|\\babstract\\b|\\basync\\b|\\bclass\\b|\\bconst\\b|\\bdeclare\\b|\\benum\\b|\\bexport\\b|\\bfunction\\b|\\bimport\\b|\\binterface\\b|\\blet\\b|\\bmodule\\b|\\bnamespace\\b|\\btype\\b|\\bvar\\b)"
        patterns: [
          {
            include: "#expression"
          }
        ]
      }
      {
        name: "meta.export.ts"
        begin: "(?<!\\.|\\$)\\b(export)(?!(\\s*:)|(\\$))\\b"
        beginCaptures:
          "0":
            name: "keyword.control.export.ts"
        end: "(?=;|$|\\babstract\\b|\\basync\\b|\\bclass\\b|\\bconst\\b|\\bdeclare\\b|\\benum\\b|\\bexport\\b|\\bfunction\\b|\\bimport\\b|\\binterface\\b|\\blet\\b|\\bmodule\\b|\\bnamespace\\b|\\btype\\b|\\bvar\\b)"
        patterns: [
          {
            include: "#import-export-declaration"
          }
        ]
      }
    ]
  "import-export-declaration":
    patterns: [
      {
        include: "#comment"
      }
      {
        include: "#string"
      }
      {
        include: "#import-export-block"
      }
      {
        name: "keyword.control.from.ts"
        match: "\\bfrom\\b"
      }
      {
        include: "#import-export-clause"
      }
    ]
  "import-export-block":
    name: "meta.block.ts"
    begin: "\\{"
    beginCaptures:
      "0":
        name: "punctuation.definition.block.ts"
    end: "\\}"
    endCaptures:
      "0":
        name: "punctuation.definition.block.ts"
    patterns: [
      {
        include: "#import-export-clause"
      }
    ]
  "import-export-clause":
    patterns: [
      {
        include: "#comment"
      }
      {
        comment: "(default|*|name) as alias"
        match: '''
          (?x) (?: \\b(default)\\b | (\\*) | ([_$[:alpha:]][_$[:alnum:]]*)) \\s+
            (as) \\s+ (?: (\\b default \\b | \\*) | ([_$[:alpha:]][_$[:alnum:]]*))
        '''
        captures:
          "1":
            name: "keyword.control.default.ts"
          "2":
            name: "constant.language.import-export-all.ts"
          "3":
            name: "variable.other.readwrite.ts"
          "4":
            name: "keyword.control.as.ts"
          "5":
            name: "invalid.illegal.ts"
          "6":
            name: "variable.other.readwrite.alias.ts"
      }
      {
        include: "#punctuation-comma"
      }
      {
        name: "constant.language.import-export-all.ts"
        match: "\\*"
      }
      {
        name: "keyword.control.default.ts"
        match: "\\b(default)\\b"
      }
      {
        name: "variable.other.readwrite.alias.ts"
        match: "([_$[:alpha:]][_$[:alnum:]]*)"
      }
    ]
  "switch-statement":
    name: "switch-statement.expr.ts"
    begin: "(?<!\\.|\\$)(?=\\bswitch\\s*\\()"
    end: "\\}"
    endCaptures:
      "0":
        name: "punctuation.definition.block.ts"
    patterns: [
      {
        name: "switch-expression.expr.ts"
        begin: "(?<!\\.|\\$)\\b(switch)\\s*(\\()"
        beginCaptures:
          "1":
            name: "keyword.control.switch.ts"
          "2":
            name: "meta.brace.round.ts"
        end: "\\)"
        endCaptures:
          "0":
            name: "meta.brace.round.ts"
        patterns: [
          {
            include: "#expression"
          }
        ]
      }
      {
        name: "switch-block.expr.ts"
        begin: "\\{"
        beginCaptures:
          "0":
            name: "punctuation.definition.block.ts"
        end: "(?=\\})"
        patterns: [
          {
            name: "case-clause.expr.ts"
            begin: "(?<!\\.|\\$)\\b(case|default(?=:))\\b(?!\\$|\\.)"
            beginCaptures:
              "1":
                name: "keyword.control.switch.ts"
            end: ":"
            endCaptures:
              "0":
                name: "punctuation.definition.section.case-statement.ts"
            patterns: [
              {
                include: "#expression"
              }
            ]
          }
          {
            include: "#statements"
          }
        ]
      }
    ]
  "for-loop":
    begin: "(?<!\\.|\\$)\\b(for)(?:\\s+(await))?\\s*(\\()"
    beginCaptures:
      "1":
        name: "keyword.control.loop.ts"
      "2":
        name: "keyword.control.loop.ts"
      "3":
        name: "meta.brace.round.ts"
    end: "\\)"
    endCaptures:
      "0":
        name: "meta.brace.round.ts"
    patterns: [
      {
        include: "#var-expr"
      }
      {
        include: "#expression"
      }
      {
        include: "#punctuation-semicolon"
      }
    ]
  "decl-block":
    name: "meta.block.ts"
    begin: "\\{"
    beginCaptures:
      "0":
        name: "punctuation.definition.block.ts"
    end: "\\}"
    endCaptures:
      "0":
        name: "punctuation.definition.block.ts"
    patterns: [
      {
        include: "#statements"
      }
    ]
  "after-operator-block-as-object-literal":
    name: "meta.objectliteral.ts"
    begin: "(?<=[=(,\\[?+!]|await|return|yield|throw|in|of|typeof|&&|\\|\\||\\*)\\s*(\\{)"
    beginCaptures:
      "1":
        name: "punctuation.definition.block.ts"
    end: "\\}"
    endCaptures:
      "0":
        name: "punctuation.definition.block.ts"
    patterns: [
      {
        include: "#object-member"
      }
    ]
  "object-literal":
    name: "meta.objectliteral.ts"
    begin: "\\{"
    beginCaptures:
      "0":
        name: "punctuation.definition.block.ts"
    end: "\\}"
    endCaptures:
      "0":
        name: "punctuation.definition.block.ts"
    patterns: [
      {
        include: "#object-member"
      }
    ]
  "object-member":
    patterns: [
      {
        include: "#comment"
      }
      {
        include: "#object-literal-method-declaration"
      }
      {
        name: "meta.object.member.ts meta.object-literal.key.ts"
        begin: "(?=\\[)"
        end: "(?=:)"
        patterns: [
          {
            include: "#array-literal"
          }
        ]
      }
      {
        name: "meta.object.member.ts meta.object-literal.key.ts"
        begin: "(?=[\\'\\\"])"
        end: "(?=:)"
        patterns: [
          {
            include: "#string"
          }
        ]
      }
      {
        name: "meta.object.member.ts"
        match: "(?![_$[:alpha:]])([[:digit:]]+)\\s*(?=:)"
        captures:
          "0":
            name: "meta.object-literal.key.ts"
          "1":
            name: "constant.numeric.decimal.ts"
      }
      {
        name: "meta.object.member.ts"
        match: '''
          (?x)(?:([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=:\\s*(
            ((async\\s+)?(
              (function\\s*[(<*]) |
              (function\\s+) |
              ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)
            )) |
            ((async\\s*)?(
              # sure shot arrow functions even if => is on new line
          (
            [(]\\s*
            (
              ([)]\\s*:) |                                                                 # ():
              ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                            # [(]param: | [(]...param:
            )
          ) |
          (
            [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                        # < typeparam extends
          ) |
          # arrow function possible to detect only with => on same line
          (
            (<\\s*[_$[:alpha:]\\{\\(\\[]([^<>=]|=[^<]|\\<\\s*[_$[:alpha:]\\{\\(\\[]([^=<>]|=[^<])+\\>)+>\\s*)?                                                           # typeparameters
            \\((\\s*[_$[:alpha:]\\{\\(]([^()]|\\((\\s*[_$[:alpha:]\\{\\(]\\{\\(][^()]*)?\\))*)?\\)    # parameteres
            (\\s*:\\s*([^<>\\(\\)]|\\<[^<>]+\\>|\\([^\\(\\)]+\\))+)?                                # return type
            \\s*=>                                                                         # arrow operator
          )
            ))
          )))
        '''
        captures:
          "0":
            name: "meta.object-literal.key.ts"
          "1":
            name: "entity.name.function.ts"
      }
      {
        name: "meta.object.member.ts"
        match: "(?:[_$[:alpha:]][_$[:alnum:]]*)\\s*(?=:)"
        captures:
          "0":
            name: "meta.object-literal.key.ts"
      }
      {
        name: "meta.object.member.ts"
        begin: "\\.\\.\\."
        beginCaptures:
          "0":
            name: "keyword.operator.spread.ts"
        end: "(?=,|\\})"
        patterns: [
          {
            include: "#expression"
          }
        ]
      }
      {
        name: "meta.object.member.ts"
        match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(?=,|\\}|$)"
        captures:
          "1":
            name: "variable.other.readwrite.ts"
      }
      {
        name: "meta.object.member.ts"
        begin: "(?=[_$[:alpha:]][_$[:alnum:]]*\\s*=)"
        end: "(?=,|\\}|$)"
        patterns: [
          {
            include: "#expression"
          }
        ]
      }
      {
        name: "meta.object.member.ts"
        begin: ":"
        beginCaptures:
          "0":
            name: "meta.object-literal.key.ts punctuation.separator.key-value.ts"
        end: "(?=,|\\})"
        patterns: [
          {
            include: "#expression"
          }
        ]
      }
      {
        include: "#punctuation-comma"
      }
    ]
  "ternary-expression":
    begin: "(\\?)"
    beginCaptures:
      "0":
        name: "keyword.operator.ternary.ts"
    end: "(:)"
    endCaptures:
      "0":
        name: "keyword.operator.ternary.ts"
    patterns: [
      {
        include: "#expression"
      }
    ]
  "function-call":
    begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*\\s*\\.\\s*)*|(\\.\\s*)?)([_$[:alpha:]][_$[:alnum:]]*)\\s*(<\\s*[_$[:alpha:]\\{\\(\\[]([^<>=]|=[^<]|\\<\\s*[_$[:alpha:]\\{\\(\\[]([^=<>]|=[^<])+\\>)+>\\s*)?\\()"
    end: "(?<=\\))(?!(([_$[:alpha:]][_$[:alnum:]]*\\s*\\.\\s*)*|(\\.\\s*)?)([_$[:alpha:]][_$[:alnum:]]*)\\s*(<\\s*[_$[:alpha:]\\{\\(\\[]([^<>=]|=[^<]|\\<\\s*[_$[:alpha:]\\{\\(\\[]([^=<>]|=[^<])+\\>)+>\\s*)?\\()"
    patterns: [
      {
        name: "meta.function-call.ts"
        begin: "(?=(([_$[:alpha:]][_$[:alnum:]]*\\s*\\.\\s*)*|(\\.\\s*)?)([_$[:alpha:]][_$[:alnum:]]*))"
        end: "(?=\\s*(<\\s*[_$[:alpha:]\\{\\(\\[]([^<>=]|=[^<]|\\<\\s*[_$[:alpha:]\\{\\(\\[]([^=<>]|=[^<])+\\>)+>\\s*)?\\()"
        patterns: [
          {
            include: "#literal"
          }
          {
            include: "#support-objects"
          }
          {
            include: "#object-identifiers"
          }
          {
            include: "#punctuation-accessor"
          }
          {
            name: "keyword.operator.expression.import.ts"
            match: "(?![\\.\\$])\\bimport(?=\\s*[\\(]\\s*[\\\"\\'\\`])"
          }
          {
            name: "entity.name.function.ts"
            match: "([_$[:alpha:]][_$[:alnum:]]*)"
          }
        ]
      }
      {
        include: "#comment"
      }
      {
        name: "meta.type.parameters.ts"
        begin: "\\<"
        beginCaptures:
          "0":
            name: "punctuation.definition.typeparameters.begin.ts"
        end: "\\>"
        endCaptures:
          "0":
            name: "punctuation.definition.typeparameters.end.ts"
        patterns: [
          {
            include: "#type"
          }
          {
            include: "#punctuation-comma"
          }
        ]
      }
      {
        include: "#paren-expression"
      }
    ]
  "new-expr":
    name: "new.expr.ts"
    begin: "(?<!\\.|\\$)\\b(new)\\b(?!\\$|\\.)"
    beginCaptures:
      "1":
        name: "keyword.operator.new.ts"
    end: "(?<=\\))|(?=[;),}\\]]|$|((?<!\\.|\\$)\\bnew\\b(?!\\$|\\.))|((?<!\\.|\\$)\\bfunction((\\s+[_$[:alpha:]][_$[:alnum:]]*)|(\\s*[\\(]))))"
    patterns: [
      {
        include: "#paren-expression"
      }
      {
        include: "#class-declaration"
      }
      {
        include: "#type"
      }
    ]
  "paren-expression":
    begin: "\\("
    beginCaptures:
      "0":
        name: "meta.brace.round.ts"
    end: "\\)"
    endCaptures:
      "0":
        name: "meta.brace.round.ts"
    patterns: [
      {
        include: "#expression"
      }
      {
        include: "#punctuation-comma"
      }
    ]
  cast:
    patterns: [
      {
        name: "cast.expr.ts"
        begin: "(?:(?<=return|throw|yield|await|default|[=(,:>*?]|[^+]\\+))\\s*(<)(?!<?\\=)"
        beginCaptures:
          "1":
            name: "meta.brace.angle.ts"
        end: "(\\>)\\s*"
        endCaptures:
          "1":
            name: "meta.brace.angle.ts"
        patterns: [
          {
            include: "#type"
          }
        ]
      }
      {
        name: "cast.expr.ts"
        begin: "(?:(?<=^))\\s*(<)(?=[_$[:alpha:]][_$[:alnum:]]*\\s*>)"
        beginCaptures:
          "1":
            name: "meta.brace.angle.ts"
        end: "(\\>)\\s*"
        endCaptures:
          "1":
            name: "meta.brace.angle.ts"
        patterns: [
          {
            include: "#type"
          }
        ]
      }
    ]
  "expression-operators":
    patterns: [
      {
        name: "keyword.control.flow.ts"
        match: "(?<!\\.|\\$)\\b(await)\\b(?!\\$|\\.)"
      }
      {
        match: "(?<!\\.|\\$)\\b(yield)\\b(?!\\$|\\.)(?:\\s*(\\*))?"
        captures:
          "1":
            name: "keyword.control.flow.ts"
          "2":
            name: "keyword.generator.asterisk.ts"
      }
      {
        name: "keyword.operator.expression.delete.ts"
        match: "(?<!\\.|\\$)\\bdelete\\b(?!\\$|\\.)"
      }
      {
        name: "keyword.operator.expression.in.ts"
        match: "(?<!\\.|\\$)\\bin\\b(?!\\$|\\.)"
      }
      {
        name: "keyword.operator.expression.of.ts"
        match: "(?<!\\.|\\$)\\bof\\b(?!\\$|\\.)"
      }
      {
        name: "keyword.operator.expression.instanceof.ts"
        match: "(?<!\\.|\\$)\\binstanceof\\b(?!\\$|\\.)"
      }
      {
        name: "keyword.operator.new.ts"
        match: "(?<!\\.|\\$)\\bnew\\b(?!\\$|\\.)"
      }
      {
        include: "#typeof-operator"
      }
      {
        name: "keyword.operator.expression.void.ts"
        match: "(?<!\\.|\\$)\\bvoid\\b(?!\\$|\\.)"
      }
      {
        begin: "(?<!\\.|\\$)\\b(as)\\s+"
        beginCaptures:
          "1":
            name: "keyword.control.as.ts"
        end: "(?=$|^|[;,:})\\]]|((?<!\\.|\\$)\\b(as)\\s+))"
        patterns: [
          {
            include: "#type"
          }
        ]
      }
      {
        name: "keyword.operator.spread.ts"
        match: "\\.\\.\\."
      }
      {
        name: "keyword.operator.assignment.compound.ts"
        match: "\\*=|(?<!\\()/=|%=|\\+=|\\-="
      }
      {
        name: "keyword.operator.assignment.compound.bitwise.ts"
        match: "\\&=|\\^=|<<=|>>=|>>>=|\\|="
      }
      {
        name: "keyword.operator.bitwise.shift.ts"
        match: "<<|>>>|>>"
      }
      {
        name: "keyword.operator.comparison.ts"
        match: "===|!==|==|!="
      }
      {
        name: "keyword.operator.relational.ts"
        match: "<=|>=|<>|<|>"
      }
      {
        name: "keyword.operator.logical.ts"
        match: "\\!|&&|\\|\\|"
      }
      {
        name: "keyword.operator.bitwise.ts"
        match: "\\&|~|\\^|\\|"
      }
      {
        name: "keyword.operator.assignment.ts"
        match: "\\="
      }
      {
        name: "keyword.operator.decrement.ts"
        match: "--"
      }
      {
        name: "keyword.operator.increment.ts"
        match: "\\+\\+"
      }
      {
        name: "keyword.operator.arithmetic.ts"
        match: "%|\\*|/|-|\\+"
      }
      {
        match: "(?<=[_$[:alnum:])])\\s*(/)(?![/*])"
        captures:
          "1":
            name: "keyword.operator.arithmetic.ts"
      }
    ]
  "typeof-operator":
    name: "keyword.operator.expression.typeof.ts"
    match: "(?<!\\.|\\$)\\btypeof\\b(?!\\$|\\.)"
  literal:
    patterns: [
      {
        include: "#numeric-literal"
      }
      {
        include: "#boolean-literal"
      }
      {
        include: "#null-literal"
      }
      {
        include: "#undefined-literal"
      }
      {
        include: "#numericConstant-literal"
      }
      {
        include: "#array-literal"
      }
      {
        include: "#this-literal"
      }
      {
        include: "#super-literal"
      }
    ]
  "array-literal":
    name: "meta.array.literal.ts"
    begin: "\\["
    beginCaptures:
      "0":
        name: "meta.brace.square.ts"
    end: "\\]"
    endCaptures:
      "0":
        name: "meta.brace.square.ts"
    patterns: [
      {
        include: "#expression"
      }
      {
        include: "#punctuation-comma"
      }
    ]
  "numeric-literal":
    patterns: [
      {
        name: "constant.numeric.hex.ts"
        match: "\\b(?<!\\$)0(x|X)[0-9a-fA-F]+\\b(?!\\$)"
      }
      {
        name: "constant.numeric.binary.ts"
        match: "\\b(?<!\\$)0(b|B)[01]+\\b(?!\\$)"
      }
      {
        name: "constant.numeric.octal.ts"
        match: "\\b(?<!\\$)0(o|O)?[0-7]+\\b(?!\\$)"
      }
      {
        match: '''
          (?x)
          (?<!\\$)(?:
            (?:\\b[0-9]+(\\.)[0-9]+[eE][+-]?[0-9]+\\b)| # 1.1E+3
            (?:\\b[0-9]+(\\.)[eE][+-]?[0-9]+\\b)|       # 1.E+3
            (?:\\B(\\.)[0-9]+[eE][+-]?[0-9]+\\b)|       # .1E+3
            (?:\\b[0-9]+[eE][+-]?[0-9]+\\b)|           # 1E+3
            (?:\\b[0-9]+(\\.)[0-9]+\\b)|                # 1.1
            (?:\\b[0-9]+(\\.)\\B)|                      # 1.
            (?:\\B(\\.)[0-9]+\\b)|                      # .1
            (?:\\b[0-9]+\\b(?!\\.))                     # 1
          )(?!\\$)
        '''
        captures:
          "0":
            name: "constant.numeric.decimal.ts"
          "1":
            name: "meta.delimiter.decimal.period.ts"
          "2":
            name: "meta.delimiter.decimal.period.ts"
          "3":
            name: "meta.delimiter.decimal.period.ts"
          "4":
            name: "meta.delimiter.decimal.period.ts"
          "5":
            name: "meta.delimiter.decimal.period.ts"
          "6":
            name: "meta.delimiter.decimal.period.ts"
      }
    ]
  "boolean-literal":
    patterns: [
      {
        name: "constant.language.boolean.true.ts"
        match: "(?<!\\.|\\$)\\btrue\\b(?!\\$)"
      }
      {
        name: "constant.language.boolean.false.ts"
        match: "(?<!\\.|\\$)\\bfalse\\b(?!\\$)"
      }
    ]
  "null-literal":
    name: "constant.language.null.ts"
    match: "(?<!\\.|\\$)\\bnull\\b(?!\\$)"
  "this-literal":
    name: "variable.language.this.ts"
    match: "(?<!\\$)((?<=\\.\\.\\.)|(?<!\\.))\\bthis\\b(?!\\$)"
  "super-literal":
    name: "variable.language.super.ts"
    match: "(?<!\\.|\\$)\\bsuper\\b(?!\\$)"
  "undefined-literal":
    name: "constant.language.undefined.ts"
    match: "(?<!\\.|\\$)\\bundefined\\b(?!\\$)"
  "numericConstant-literal":
    patterns: [
      {
        name: "constant.language.nan.ts"
        match: "(?<!\\.|\\$)\\bNaN\\b(?!\\$)"
      }
      {
        name: "constant.language.infinity.ts"
        match: "(?<!\\.|\\$)\\bInfinity\\b(?!\\$)"
      }
    ]
  "support-objects":
    patterns: [
      {
        name: "variable.language.arguments.ts"
        match: "(?<!\\.|\\$)\\b(arguments)\\b(?!\\$)"
      }
      {
        name: "support.class.builtin.ts"
        match: '''
          (?x)(?<!\\.|\\$)\\b(Array|ArrayBuffer|Atomics|Boolean|DataView|Date|Float32Array|Float64Array|Function|Generator
            |GeneratorFunction|Int8Array|Int16Array|Int32Array|Intl|Map|Number|Object|Promise|Proxy
            |Reflect|RegExp|Set|SharedArrayBuffer|SIMD|String|Symbol|TypedArray
            |Uint8Array|Uint16Array|Uint32Array|Uint8ClampedArray|WeakMap|WeakSet)\\b(?!\\$)
        '''
      }
      {
        name: "support.class.error.ts"
        match: "(?<!\\.|\\$)\\b((Eval|Internal|Range|Reference|Syntax|Type|URI)?Error)\\b(?!\\$)"
      }
      {
        name: "support.function.ts"
        match: '''
          (?x)(?<!\\.|\\$)\\b(clear(Interval|Timeout)|decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|escape|eval|
            isFinite|isNaN|parseFloat|parseInt|require|set(Interval|Timeout)|super|unescape|uneval)(?=\\s*\\()
        '''
      }
      {
        match: '''
          (?x)(?<!\\.|\\$)\\b(Math)(?:\\s*(\\.)\\s*(?:
            (abs|acos|acosh|asin|asinh|atan|atan2|atanh|cbrt|ceil|clz32|cos|cosh|exp|
            expm1|floor|fround|hypot|imul|log|log10|log1p|log2|max|min|pow|random|
            round|sign|sin|sinh|sqrt|tan|tanh|trunc)
            |
            (E|LN10|LN2|LOG10E|LOG2E|PI|SQRT1_2|SQRT2)))?\\b(?!\\$)
        '''
        captures:
          "1":
            name: "support.constant.math.ts"
          "2":
            name: "punctuation.accessor.ts"
          "3":
            name: "support.function.math.ts"
          "4":
            name: "support.constant.property.math.ts"
      }
      {
        match: '''
          (?x)(?<!\\.|\\$)\\b(console)(?:\\s*(\\.)\\s*(
            assert|clear|count|debug|dir|error|group|groupCollapsed|groupEnd|info|log
            |profile|profileEnd|table|time|timeEnd|timeStamp|trace|warn))?\\b(?!\\$)
        '''
        captures:
          "1":
            name: "support.class.console.ts"
          "2":
            name: "punctuation.accessor.ts"
          "3":
            name: "support.function.console.ts"
      }
      {
        match: "(?<!\\.|\\$)\\b(JSON)(?:\\s*(\\.)\\s*(parse|stringify))?\\b(?!\\$)"
        captures:
          "1":
            name: "support.constant.json.ts"
          "2":
            name: "punctuation.accessor.ts"
          "3":
            name: "support.function.json.ts"
      }
      {
        match: '''
          (?x) (\\.) \\s* (?:
            (constructor|length|prototype|__proto__)
            |
            (EPSILON|MAX_SAFE_INTEGER|MAX_VALUE|MIN_SAFE_INTEGER|MIN_VALUE|NEGATIVE_INFINITY|POSITIVE_INFINITY))\\b(?!\\$)
        '''
        captures:
          "1":
            name: "punctuation.accessor.ts"
          "2":
            name: "support.variable.property.ts"
          "3":
            name: "support.constant.ts"
      }
      {
        match: '''
          (?x) (?<!\\.|\\$) \\b (?:
            (document|event|navigator|performance|screen|window)
            |
            (AnalyserNode|ArrayBufferView|Attr|AudioBuffer|AudioBufferSourceNode|AudioContext|AudioDestinationNode|AudioListener
            |AudioNode|AudioParam|BatteryManager|BeforeUnloadEvent|BiquadFilterNode|Blob|BufferSource|ByteString|CSS|CSSConditionRule
            |CSSCounterStyleRule|CSSGroupingRule|CSSMatrix|CSSMediaRule|CSSPageRule|CSSPrimitiveValue|CSSRule|CSSRuleList|CSSStyleDeclaration
            |CSSStyleRule|CSSStyleSheet|CSSSupportsRule|CSSValue|CSSValueList|CanvasGradient|CanvasImageSource|CanvasPattern
            |CanvasRenderingContext2D|ChannelMergerNode|ChannelSplitterNode|CharacterData|ChromeWorker|CloseEvent|Comment|CompositionEvent
            |Console|ConvolverNode|Coordinates|Credential|CredentialsContainer|Crypto|CryptoKey|CustomEvent|DOMError|DOMException
            |DOMHighResTimeStamp|DOMImplementation|DOMString|DOMStringList|DOMStringMap|DOMTimeStamp|DOMTokenList|DataTransfer
            |DataTransferItem|DataTransferItemList|DedicatedWorkerGlobalScope|DelayNode|DeviceProximityEvent|DirectoryEntry
            |DirectoryEntrySync|DirectoryReader|DirectoryReaderSync|Document|DocumentFragment|DocumentTouch|DocumentType|DragEvent
            |DynamicsCompressorNode|Element|Entry|EntrySync|ErrorEvent|Event|EventListener|EventSource|EventTarget|FederatedCredential
            |FetchEvent|File|FileEntry|FileEntrySync|FileException|FileList|FileReader|FileReaderSync|FileSystem|FileSystemSync
            |FontFace|FormData|GainNode|Gamepad|GamepadButton|GamepadEvent|Geolocation|GlobalEventHandlers|HTMLAnchorElement
            |HTMLAreaElement|HTMLAudioElement|HTMLBRElement|HTMLBaseElement|HTMLBodyElement|HTMLButtonElement|HTMLCanvasElement
            |HTMLCollection|HTMLContentElement|HTMLDListElement|HTMLDataElement|HTMLDataListElement|HTMLDialogElement|HTMLDivElement
            |HTMLDocument|HTMLElement|HTMLEmbedElement|HTMLFieldSetElement|HTMLFontElement|HTMLFormControlsCollection|HTMLFormElement
            |HTMLHRElement|HTMLHeadElement|HTMLHeadingElement|HTMLHtmlElement|HTMLIFrameElement|HTMLImageElement|HTMLInputElement
            |HTMLKeygenElement|HTMLLIElement|HTMLLabelElement|HTMLLegendElement|HTMLLinkElement|HTMLMapElement|HTMLMediaElement
            |HTMLMetaElement|HTMLMeterElement|HTMLModElement|HTMLOListElement|HTMLObjectElement|HTMLOptGroupElement|HTMLOptionElement
            |HTMLOptionsCollection|HTMLOutputElement|HTMLParagraphElement|HTMLParamElement|HTMLPreElement|HTMLProgressElement
            |HTMLQuoteElement|HTMLScriptElement|HTMLSelectElement|HTMLShadowElement|HTMLSourceElement|HTMLSpanElement|HTMLStyleElement
            |HTMLTableCaptionElement|HTMLTableCellElement|HTMLTableColElement|HTMLTableDataCellElement|HTMLTableElement|HTMLTableHeaderCellElement
            |HTMLTableRowElement|HTMLTableSectionElement|HTMLTextAreaElement|HTMLTimeElement|HTMLTitleElement|HTMLTrackElement
            |HTMLUListElement|HTMLUnknownElement|HTMLVideoElement|HashChangeEvent|History|IDBCursor|IDBCursorWithValue|IDBDatabase
            |IDBEnvironment|IDBFactory|IDBIndex|IDBKeyRange|IDBMutableFile|IDBObjectStore|IDBOpenDBRequest|IDBRequest|IDBTransaction
            |IDBVersionChangeEvent|IIRFilterNode|IdentityManager|ImageBitmap|ImageBitmapFactories|ImageData|Index|InputDeviceCapabilities
            |InputEvent|InstallEvent|InstallTrigger|KeyboardEvent|LinkStyle|LocalFileSystem|LocalFileSystemSync|Location|MIDIAccess
            |MIDIConnectionEvent|MIDIInput|MIDIInputMap|MIDIOutputMap|MediaElementAudioSourceNode|MediaError|MediaKeyMessageEvent
            |MediaKeySession|MediaKeyStatusMap|MediaKeySystemAccess|MediaKeySystemConfiguration|MediaKeys|MediaRecorder|MediaStream
            |MediaStreamAudioDestinationNode|MediaStreamAudioSourceNode|MessageChannel|MessageEvent|MessagePort|MouseEvent
            |MutationObserver|MutationRecord|NamedNodeMap|Navigator|NavigatorConcurrentHardware|NavigatorGeolocation|NavigatorID
            |NavigatorLanguage|NavigatorOnLine|Node|NodeFilter|NodeIterator|NodeList|NonDocumentTypeChildNode|Notification
            |OfflineAudioCompletionEvent|OfflineAudioContext|OscillatorNode|PageTransitionEvent|PannerNode|ParentNode|PasswordCredential
            |Path2D|PaymentAddress|PaymentRequest|PaymentResponse|Performance|PerformanceEntry|PerformanceFrameTiming|PerformanceMark
            |PerformanceMeasure|PerformanceNavigation|PerformanceNavigationTiming|PerformanceObserver|PerformanceObserverEntryList
            |PerformanceResourceTiming|PerformanceTiming|PeriodicSyncEvent|PeriodicWave|Plugin|Point|PointerEvent|PopStateEvent
            |PortCollection|Position|PositionError|PositionOptions|PresentationConnectionClosedEvent|PresentationConnectionList
            |PresentationReceiver|ProcessingInstruction|ProgressEvent|PromiseRejectionEvent|PushEvent|PushRegistrationManager
            |RTCCertificate|RTCConfiguration|RTCPeerConnection|RTCSessionDescriptionCallback|RTCStatsReport|RadioNodeList|RandomSource
            |Range|ReadableByteStream|RenderingContext|SVGAElement|SVGAngle|SVGAnimateColorElement|SVGAnimateElement|SVGAnimateMotionElement
            |SVGAnimateTransformElement|SVGAnimatedAngle|SVGAnimatedBoolean|SVGAnimatedEnumeration|SVGAnimatedInteger|SVGAnimatedLength
            |SVGAnimatedLengthList|SVGAnimatedNumber|SVGAnimatedNumberList|SVGAnimatedPoints|SVGAnimatedPreserveAspectRatio
            |SVGAnimatedRect|SVGAnimatedString|SVGAnimatedTransformList|SVGAnimationElement|SVGCircleElement|SVGClipPathElement
            |SVGCursorElement|SVGDefsElement|SVGDescElement|SVGElement|SVGEllipseElement|SVGEvent|SVGFilterElement|SVGFontElement
            |SVGFontFaceElement|SVGFontFaceFormatElement|SVGFontFaceNameElement|SVGFontFaceSrcElement|SVGFontFaceUriElement
            |SVGForeignObjectElement|SVGGElement|SVGGlyphElement|SVGGradientElement|SVGHKernElement|SVGImageElement|SVGLength
            |SVGLengthList|SVGLineElement|SVGLinearGradientElement|SVGMPathElement|SVGMaskElement|SVGMatrix|SVGMissingGlyphElement
            |SVGNumber|SVGNumberList|SVGPathElement|SVGPatternElement|SVGPoint|SVGPolygonElement|SVGPolylineElement|SVGPreserveAspectRatio
            |SVGRadialGradientElement|SVGRect|SVGRectElement|SVGSVGElement|SVGScriptElement|SVGSetElement|SVGStopElement|SVGStringList
            |SVGStylable|SVGStyleElement|SVGSwitchElement|SVGSymbolElement|SVGTRefElement|SVGTSpanElement|SVGTests|SVGTextElement
            |SVGTextPositioningElement|SVGTitleElement|SVGTransform|SVGTransformList|SVGTransformable|SVGUseElement|SVGVKernElement
            |SVGViewElement|ServiceWorker|ServiceWorkerContainer|ServiceWorkerGlobalScope|ServiceWorkerRegistration|ServiceWorkerState
            |ShadowRoot|SharedWorker|SharedWorkerGlobalScope|SourceBufferList|StereoPannerNode|Storage|StorageEvent|StyleSheet
            |StyleSheetList|SubtleCrypto|SyncEvent|Text|TextMetrics|TimeEvent|TimeRanges|Touch|TouchEvent|TouchList|Transferable
            |TreeWalker|UIEvent|USVString|VRDisplayCapabilities|ValidityState|WaveShaperNode|WebGL|WebGLActiveInfo|WebGLBuffer
            |WebGLContextEvent|WebGLFramebuffer|WebGLProgram|WebGLRenderbuffer|WebGLRenderingContext|WebGLShader|WebGLShaderPrecisionFormat
            |WebGLTexture|WebGLTimerQueryEXT|WebGLTransformFeedback|WebGLUniformLocation|WebGLVertexArrayObject|WebGLVertexArrayObjectOES
            |WebSocket|WebSockets|WebVTT|WheelEvent|Window|WindowBase64|WindowEventHandlers|WindowTimers|Worker|WorkerGlobalScope
            |WorkerLocation|WorkerNavigator|XMLHttpRequest|XMLHttpRequestEventTarget|XMLSerializer|XPathExpression|XPathResult
            |XSLTProcessor))\\b(?!\\$)
        '''
        captures:
          "1":
            name: "support.variable.dom.ts"
          "2":
            name: "support.class.dom.ts"
      }
      {
        match: '''
          (?x) (\\.) \\s* (?:
            (ATTRIBUTE_NODE|CDATA_SECTION_NODE|COMMENT_NODE|DOCUMENT_FRAGMENT_NODE|DOCUMENT_NODE|DOCUMENT_TYPE_NODE
            |DOMSTRING_SIZE_ERR|ELEMENT_NODE|ENTITY_NODE|ENTITY_REFERENCE_NODE|HIERARCHY_REQUEST_ERR|INDEX_SIZE_ERR
            |INUSE_ATTRIBUTE_ERR|INVALID_CHARACTER_ERR|NO_DATA_ALLOWED_ERR|NO_MODIFICATION_ALLOWED_ERR|NOT_FOUND_ERR
            |NOT_SUPPORTED_ERR|NOTATION_NODE|PROCESSING_INSTRUCTION_NODE|TEXT_NODE|WRONG_DOCUMENT_ERR)
            |
            (_content|[xyz]|abbr|above|accept|acceptCharset|accessKey|action|align|[av]Link(?:color)?|all|alt|anchors|appCodeName
            |appCore|applets|appMinorVersion|appName|appVersion|archive|areas|arguments|attributes|availHeight|availLeft|availTop
            |availWidth|axis|background|backgroundColor|backgroundImage|below|bgColor|body|border|borderBottomWidth|borderColor
            |borderLeftWidth|borderRightWidth|borderStyle|borderTopWidth|borderWidth|bottom|bufferDepth|callee|caller|caption
            |cellPadding|cells|cellSpacing|ch|characterSet|charset|checked|childNodes|chOff|cite|classes|className|clear
            |clientInformation|clip|clipBoardData|closed|code|codeBase|codeType|color|colorDepth|cols|colSpan|compact|complete
            |components|content|controllers|cookie|cookieEnabled|cords|cpuClass|crypto|current|data|dateTime|declare|defaultCharset
            |defaultChecked|defaultSelected|defaultStatus|defaultValue|defaultView|defer|description|dialogArguments|dialogHeight
            |dialogLeft|dialogTop|dialogWidth|dir|directories|disabled|display|docmain|doctype|documentElement|elements|embeds
            |enabledPlugin|encoding|enctype|entities|event|expando|external|face|fgColor|filename|firstChild|fontFamily|fontSize
            |fontWeight|form|formName|forms|frame|frameBorder|frameElement|frames|hasFocus|hash|headers|height|history|host
            |hostname|href|hreflang|hspace|htmlFor|httpEquiv|id|ids|ignoreCase|images|implementation|index|innerHeight|innerWidth
            |input|isMap|label|lang|language|lastChild|lastIndex|lastMatch|lastModified|lastParen|layer[sXY]|left|leftContext
            |lineHeight|link|linkColor|links|listStyleType|localName|location|locationbar|longDesc|lowsrc|lowSrc|marginBottom
            |marginHeight|marginLeft|marginRight|marginTop|marginWidth|maxLength|media|menubar|method|mimeTypes|multiline|multiple
            |name|nameProp|namespaces|namespaceURI|next|nextSibling|nodeName|nodeType|nodeValue|noHref|noResize|noShade|notationName
            |notations|noWrap|object|offscreenBuffering|onLine|onreadystatechange|opener|opsProfile|options|oscpu|outerHeight
            |outerWidth|ownerDocument|paddingBottom|paddingLeft|paddingRight|paddingTop|page[XY]|page[XY]Offset|parent|parentLayer
            |parentNode|parentWindow|pathname|personalbar|pixelDepth|pkcs11|platform|plugins|port|prefix|previous|previousDibling
            |product|productSub|profile|profileend|prompt|prompter|protocol|publicId|readOnly|readyState|referrer|rel|responseText
            |responseXML|rev|right|rightContext|rowIndex|rows|rowSpan|rules|scheme|scope|screen[XY]|screenLeft|screenTop|scripts
            |scrollbars|scrolling|sectionRowIndex|security|securityPolicy|selected|selectedIndex|selection|self|shape|siblingAbove
            |siblingBelow|size|source|specified|standby|start|status|statusbar|statusText|style|styleSheets|suffixes|summary
            |systemId|systemLanguage|tagName|tags|target|tBodies|text|textAlign|textDecoration|textIndent|textTransform|tFoot|tHead
            |title|toolbar|top|type|undefined|uniqueID|updateInterval|URL|URLUnencoded|useMap|userAgent|userLanguage|userProfile
            |vAlign|value|valueType|vendor|vendorSub|version|visibility|vspace|whiteSpace|width|X[MS]LDocument|zIndex))\\b(?!\\$|\\s*(<\\s*[_$[:alpha:]\\{\\(\\[]([^<>=]|=[^<]|\\<\\s*[_$[:alpha:]\\{\\(\\[]([^=<>]|=[^<])+\\>)+>\\s*)?\\()
        '''
        captures:
          "1":
            name: "punctuation.accessor.ts"
          "2":
            name: "support.constant.dom.ts"
          "3":
            name: "support.variable.property.dom.ts"
      }
      {
        name: "support.class.node.ts"
        match: '''
          (?x)(?<!\\.|\\$)\\b(Buffer|EventEmitter|Server|Pipe|Socket|REPLServer|ReadStream|WriteStream|Stream
            |Inflate|Deflate|InflateRaw|DeflateRaw|GZip|GUnzip|Unzip|Zip)\\b(?!\\$)
        '''
      }
      {
        match: '''
          (?x)(?<!\\.|\\$)\\b(process)(?:(\\.)(?:
            (arch|argv|config|connected|env|execArgv|execPath|exitCode|mainModule|pid|platform|release|stderr|stdin|stdout|title|version|versions)
            |
            (abort|chdir|cwd|disconnect|exit|[sg]ete?[gu]id|send|[sg]etgroups|initgroups|kill|memoryUsage|nextTick|umask|uptime|hrtime)
          ))?\\b(?!\\$)
        '''
        captures:
          "1":
            name: "support.variable.object.process.ts"
          "2":
            name: "punctuation.accessor.ts"
          "3":
            name: "support.variable.property.process.ts"
          "4":
            name: "support.function.process.ts"
      }
      {
        match: "(?<!\\.|\\$)\\b(?:(exports)|(module)(?:(\\.)(exports|id|filename|loaded|parent|children))?)\\b(?!\\$)"
        captures:
          "1":
            name: "support.type.object.module.ts"
          "2":
            name: "support.type.object.module.ts"
          "3":
            name: "punctuation.accessor.ts"
          "4":
            name: "support.type.object.module.ts"
      }
      {
        name: "support.variable.object.node.ts"
        match: "(?<!\\.|\\$)\\b(global|GLOBAL|root|__dirname|__filename)\\b(?!\\$)"
      }
      {
        match: '''
          (?x) (\\.) \\s*
          (?:
           (on(?:Rowsinserted|Rowsdelete|Rowenter|Rowexit|Resize|Resizestart|Resizeend|Reset|
             Readystatechange|Mouseout|Mouseover|Mousedown|Mouseup|Mousemove|
             Before(?:cut|deactivate|unload|update|paste|print|editfocus|activate)|
             Blur|Scrolltop|Submit|Select|Selectstart|Selectionchange|Hover|Help|
             Change|Contextmenu|Controlselect|Cut|Cellchange|Clock|Close|Deactivate|
             Datasetchanged|Datasetcomplete|Dataavailable|Drop|Drag|Dragstart|Dragover|
             Dragdrop|Dragenter|Dragend|Dragleave|Dblclick|Unload|Paste|Propertychange|Error|
             Errorupdate|Keydown|Keyup|Keypress|Focus|Load|Activate|Afterupdate|Afterprint|Abort)
           ) |
           (shift|showModelessDialog|showModalDialog|showHelp|scroll|scrollX|scrollByPages|
             scrollByLines|scrollY|scrollTo|stop|strike|sizeToContent|sidebar|signText|sort|
             sup|sub|substr|substring|splice|split|send|set(?:Milliseconds|Seconds|Minutes|Hours|
             Month|Year|FullYear|Date|UTC(?:Milliseconds|Seconds|Minutes|Hours|Month|FullYear|Date)|
             Time|Hotkeys|Cursor|ZOptions|Active|Resizable|RequestHeader)|search|slice|
             savePreferences|small|home|handleEvent|navigate|char|charCodeAt|charAt|concat|
             contextual|confirm|compile|clear|captureEvents|call|createStyleSheet|createPopup|
             createEventObject|to(?:GMTString|UTCString|String|Source|UpperCase|LowerCase|LocaleString)|
             test|taint|taintEnabled|indexOf|italics|disableExternalCapture|dump|detachEvent|unshift|
             untaint|unwatch|updateCommands|join|javaEnabled|pop|push|plugins.refresh|paddings|parse|
             print|prompt|preference|enableExternalCapture|exec|execScript|valueOf|UTC|find|file|
             fileModifiedDate|fileSize|fileCreatedDate|fileUpdatedDate|fixed|fontsize|fontcolor|
             forward|fromCharCode|watch|link|load|lastIndexOf|anchor|attachEvent|atob|apply|alert|
             abort|routeEvents|resize|resizeBy|resizeTo|recalc|returnValue|replace|reverse|reload|
             releaseCapture|releaseEvents|go|get(?:Milliseconds|Seconds|Minutes|Hours|Month|Day|Year|FullYear|
             Time|Date|TimezoneOffset|UTC(?:Milliseconds|Seconds|Minutes|Hours|Day|Month|FullYear|Date)|
             Attention|Selection|ResponseHeader|AllResponseHeaders)|moveBy|moveBelow|moveTo|
             moveToAbsolute|moveAbove|mergeAttributes|match|margins|btoa|big|bold|borderWidths|blink|back
           ) |
           (acceptNode|add|addEventListener|addTextTrack|adoptNode|after|animate|append|
             appendChild|appendData|before|blur|canPlayType|captureStream|
             caretPositionFromPoint|caretRangeFromPoint|checkValidity|clear|click|
             cloneContents|cloneNode|cloneRange|close|closest|collapse|
             compareBoundaryPoints|compareDocumentPosition|comparePoint|contains|
             convertPointFromNode|convertQuadFromNode|convertRectFromNode|createAttribute|
             createAttributeNS|createCaption|createCDATASection|createComment|
             createContextualFragment|createDocument|createDocumentFragment|
             createDocumentType|createElement|createElementNS|createEntityReference|
             createEvent|createExpression|createHTMLDocument|createNodeIterator|
             createNSResolver|createProcessingInstruction|createRange|createShadowRoot|
             createTBody|createTextNode|createTFoot|createTHead|createTreeWalker|delete|
             deleteCaption|deleteCell|deleteContents|deleteData|deleteRow|deleteTFoot|
             deleteTHead|detach|disconnect|dispatchEvent|elementFromPoint|elementsFromPoint|
             enableStyleSheetsForSet|entries|evaluate|execCommand|exitFullscreen|
             exitPointerLock|expand|extractContents|fastSeek|firstChild|focus|forEach|get|
             getAll|getAnimations|getAttribute|getAttributeNames|getAttributeNode|
             getAttributeNodeNS|getAttributeNS|getBoundingClientRect|getBoxQuads|
             getClientRects|getContext|getDestinationInsertionPoints|getElementById|
             getElementsByClassName|getElementsByName|getElementsByTagName|
             getElementsByTagNameNS|getItem|getNamedItem|getSelection|getStartDate|
             getVideoPlaybackQuality|has|hasAttribute|hasAttributeNS|hasAttributes|
             hasChildNodes|hasFeature|hasFocus|importNode|initEvent|insertAdjacentElement|
             insertAdjacentHTML|insertAdjacentText|insertBefore|insertCell|insertData|
             insertNode|insertRow|intersectsNode|isDefaultNamespace|isEqualNode|
             isPointInRange|isSameNode|item|key|keys|lastChild|load|lookupNamespaceURI|
             lookupPrefix|matches|move|moveAttribute|moveAttributeNode|moveChild|
             moveNamedItem|namedItem|nextNode|nextSibling|normalize|observe|open|
             parentNode|pause|play|postMessage|prepend|preventDefault|previousNode|
             previousSibling|probablySupportsContext|queryCommandEnabled|
             queryCommandIndeterm|queryCommandState|queryCommandSupported|queryCommandValue|
             querySelector|querySelectorAll|registerContentHandler|registerElement|
             registerProtocolHandler|releaseCapture|releaseEvents|remove|removeAttribute|
             removeAttributeNode|removeAttributeNS|removeChild|removeEventListener|
             removeItem|replace|replaceChild|replaceData|replaceWith|reportValidity|
             requestFullscreen|requestPointerLock|reset|scroll|scrollBy|scrollIntoView|
             scrollTo|seekToNextFrame|select|selectNode|selectNodeContents|set|setAttribute|
             setAttributeNode|setAttributeNodeNS|setAttributeNS|setCapture|
             setCustomValidity|setEnd|setEndAfter|setEndBefore|setItem|setNamedItem|
             setRangeText|setSelectionRange|setSinkId|setStart|setStartAfter|setStartBefore|
             slice|splitText|stepDown|stepUp|stopImmediatePropagation|stopPropagation|
             submit|substringData|supports|surroundContents|takeRecords|terminate|toBlob|
             toDataURL|toggle|toString|values|write|writeln
           )
          )(?=\\s*\\()
        '''
        captures:
          "1":
            name: "punctuation.accessor.ts"
          "2":
            name: "support.function.event-handler.ts"
          "3":
            name: "support.function.ts"
          "4":
            name: "support.function.dom.ts"
      }
    ]
  identifiers:
    patterns: [
      {
        include: "#object-identifiers"
      }
      {
        match: '''
          (?x)(?:(\\.)\\s*)?([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*=\\s*(
            ((async\\s+)?(
              (function\\s*[(<*]) |
              (function\\s+) |
              ([_$[:alpha:]][_$[:alnum:]]*\\s*=>)
            )) |
            ((async\\s*)?(
              # sure shot arrow functions even if => is on new line
          (
            [(]\\s*
            (
              ([)]\\s*:) |                                                                 # ():
              ((\\.\\.\\.\\s*)?[_$[:alpha:]][_$[:alnum:]]*\\s*:)                                            # [(]param: | [(]...param:
            )
          ) |
          (
            [<]\\s*[_$[:alpha:]][_$[:alnum:]]*\\s+extends\\s*[^=>]                                        # < typeparam extends
          ) |
          # arrow function possible to detect only with => on same line
          (
            (<\\s*[_$[:alpha:]\\{\\(\\[]([^<>=]|=[^<]|\\<\\s*[_$[:alpha:]\\{\\(\\[]([^=<>]|=[^<])+\\>)+>\\s*)?                                                           # typeparameters
            \\((\\s*[_$[:alpha:]\\{\\(]([^()]|\\((\\s*[_$[:alpha:]\\{\\(]\\{\\(][^()]*)?\\))*)?\\)    # parameteres
            (\\s*:\\s*([^<>\\(\\)]|\\<[^<>]+\\>|\\([^\\(\\)]+\\))+)?                                # return type
            \\s*=>                                                                         # arrow operator
          )
            ))
          ))
        '''
        captures:
          "1":
            name: "punctuation.accessor.ts"
          "2":
            name: "entity.name.function.ts"
      }
      {
        match: "(\\.)\\s*([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])"
        captures:
          "1":
            name: "punctuation.accessor.ts"
          "2":
            name: "variable.other.constant.property.ts"
      }
      {
        match: "(\\.)\\s*([_$[:alpha:]][_$[:alnum:]]*)"
        captures:
          "1":
            name: "punctuation.accessor.ts"
          "2":
            name: "variable.other.property.ts"
      }
      {
        name: "variable.other.constant.ts"
        match: "([[:upper:]][_$[:digit:][:upper:]]*)(?![_$[:alnum:]])"
      }
      {
        name: "variable.other.readwrite.ts"
        match: "[_$[:alpha:]][_$[:alnum:]]*"
      }
    ]
  "object-identifiers":
    patterns: [
      {
        name: "support.class.ts"
        match: "([_$[:alpha:]][_$[:alnum:]]*)(?=\\s*\\.\\s*prototype\\b(?!\\$))"
      }
      {
        match: '''
          (?x)(\\.)\\s*(?:
            ([[:upper:]][_$[:digit:][:upper:]]*) |
            ([_$[:alpha:]][_$[:alnum:]]*)
          )(?=\\s*\\.\\s*[_$[:alpha:]][_$[:alnum:]]*)
        '''
        captures:
          "1":
            name: "punctuation.accessor.ts"
          "2":
            name: "variable.other.constant.object.property.ts"
          "3":
            name: "variable.other.object.property.ts"
      }
      {
        match: '''
          (?x)(?:
            ([[:upper:]][_$[:digit:][:upper:]]*) |
            ([_$[:alpha:]][_$[:alnum:]]*)
          )(?=\\s*\\.\\s*[_$[:alpha:]][_$[:alnum:]]*)
        '''
        captures:
          "1":
            name: "variable.other.constant.object.ts"
          "2":
            name: "variable.other.object.ts"
      }
    ]
  "type-annotation":
    patterns: [
      {
        name: "meta.type.annotation.ts"
        begin: "(:)(?=\\s*\\S)"
        beginCaptures:
          "1":
            name: "keyword.operator.type.annotation.ts"
        end: "(?<![:|&])((?=$|^|[,);\\}\\]]|//)|(?==[^>])|((?<=[\\}>\\]\\)]|[_$[:alpha:]])\\s*(?=\\{)))"
        patterns: [
          {
            include: "#type"
          }
        ]
      }
      {
        name: "meta.type.annotation.ts"
        begin: "(:)"
        beginCaptures:
          "1":
            name: "keyword.operator.type.annotation.ts"
        end: "(?<![:|&])((?=[,);\\}\\]]|//)|(?==[^>])|(?=^\\s*$)|((?<=\\S)(?=\\s*$))|((?<=[\\}>\\]\\)]|[_$[:alpha:]])\\s*(?=\\{)))"
        patterns: [
          {
            include: "#type"
          }
        ]
      }
    ]
  "return-type":
    patterns: [
      {
        name: "meta.return.type.ts"
        begin: "(?<=\\))\\s*(:)(?=\\s*\\S)"
        beginCaptures:
          "1":
            name: "keyword.operator.type.annotation.ts"
        end: "(?<![:|&])(?=$|^|[{};,]|//)"
        patterns: [
          {
            include: "#return-type-core"
          }
        ]
      }
      {
        name: "meta.return.type.ts"
        begin: "(?<=\\))\\s*(:)"
        beginCaptures:
          "1":
            name: "keyword.operator.type.annotation.ts"
        end: "(?<![:|&])((?=[{};,]|//|^\\s*$)|((?<=\\S)(?=\\s*$)))"
        patterns: [
          {
            include: "#return-type-core"
          }
        ]
      }
    ]
  "return-type-core":
    patterns: [
      {
        include: "#comment"
      }
      {
        begin: "(?<=[:|&])(?=\\s*\\{)"
        end: "(?<=\\})"
        patterns: [
          {
            include: "#type-object"
          }
        ]
      }
      {
        include: "#type-predicate-operator"
      }
      {
        include: "#type"
      }
    ]
  "arrow-return-type":
    name: "meta.return.type.arrow.ts"
    begin: "(?<=\\))\\s*(:)"
    beginCaptures:
      "1":
        name: "keyword.operator.type.annotation.ts"
    end: "(?==>|\\{|(^\\s*(export|function|class|interface|let|var|const|import|enum|namespace|module|type|abstract|declare)\\s+))"
    patterns: [
      {
        begin: "(?<=[:])(?=\\s*\\{)"
        end: "(?<=\\})"
        patterns: [
          {
            include: "#type-object"
          }
        ]
      }
      {
        include: "#type-predicate-operator"
      }
      {
        include: "#type"
      }
    ]
  "type-parameters":
    name: "meta.type.parameters.ts"
    begin: "(<)"
    beginCaptures:
      "1":
        name: "punctuation.definition.typeparameters.begin.ts"
    end: "(>)"
    endCaptures:
      "1":
        name: "punctuation.definition.typeparameters.end.ts"
    patterns: [
      {
        include: "#comment"
      }
      {
        name: "storage.modifier.ts"
        match: "(?<!\\.|\\$)\\b(extends)\\b(?!\\$)"
      }
      {
        name: "keyword.operator.assignment.ts"
        match: "\\=(?!>)"
      }
      {
        include: "#type"
      }
      {
        include: "#punctuation-comma"
      }
    ]
  type:
    patterns: [
      {
        include: "#comment"
      }
      {
        include: "#string"
      }
      {
        include: "#numeric-literal"
      }
      {
        include: "#type-primitive"
      }
      {
        include: "#type-builtin-literals"
      }
      {
        include: "#type-parameters"
      }
      {
        include: "#type-tuple"
      }
      {
        include: "#type-object"
      }
      {
        include: "#type-operators"
      }
      {
        include: "#type-fn-type-parameters"
      }
      {
        include: "#type-paren-or-function-parameters"
      }
      {
        include: "#type-function-return-type"
      }
      {
        include: "#type-name"
      }
    ]
  "type-primitive":
    name: "support.type.primitive.ts"
    match: "(?<!\\.|\\$)\\b(string|number|boolean|symbol|any|void|never)\\b(?!\\$|\\.)"
  "type-builtin-literals":
    name: "support.type.builtin.ts"
    match: "(?<!\\.|\\$)\\b(this|true|false|undefined|null|object)\\b(?!\\$|\\.)"
  "type-tuple":
    name: "meta.type.tuple.ts"
    begin: "\\["
    beginCaptures:
      "0":
        name: "meta.brace.square.ts"
    end: "\\]"
    endCaptures:
      "0":
        name: "meta.brace.square.ts"
    patterns: [
      {
        include: "#type"
      }
      {
        include: "#punctuation-comma"
      }
    ]
  "type-object":
    name: "meta.object.type.ts"
    begin: "\\{"
    beginCaptures:
      "0":
        name: "punctuation.definition.block.ts"
    end: "\\}"
    endCaptures:
      "0":
        name: "punctuation.definition.block.ts"
    patterns: [
      {
        include: "#comment"
      }
      {
        include: "#method-declaration"
      }
      {
        include: "#indexer-declaration"
      }
      {
        include: "#indexer-mapped-type-declaration"
      }
      {
        include: "#field-declaration"
      }
      {
        include: "#type-annotation"
      }
      {
        begin: "\\.\\.\\."
        beginCaptures:
          "0":
            name: "keyword.operator.spread.ts"
        end: "(?=\\}|;|,|$)|(?<=\\})"
        patterns: [
          {
            include: "#type"
          }
        ]
      }
      {
        include: "#punctuation-comma"
      }
      {
        include: "#punctuation-semicolon"
      }
      {
        include: "#type"
      }
    ]
  "type-paren-or-function-parameters":
    name: "meta.type.paren.cover.ts"
    begin: "\\("
    beginCaptures:
      "0":
        name: "meta.brace.round.ts"
    end: "\\)"
    endCaptures:
      "0":
        name: "meta.brace.round.ts"
    patterns: [
      {
        include: "#type"
      }
      {
        include: "#function-parameters"
      }
    ]
  "type-fn-type-parameters":
    patterns: [
      {
        name: "meta.type.constructor.ts"
        match: "(?<!\\.|\\$)\\b(new)\\b(?=\\s*\\<)"
        captures:
          "1":
            name: "keyword.control.new.ts"
      }
      {
        name: "meta.type.constructor.ts"
        begin: "(?<!\\.|\\$)\\b(new)\\b\\s*(?=\\()"
        beginCaptures:
          "1":
            name: "keyword.control.new.ts"
        end: "(?<=\\))"
        patterns: [
          {
            include: "#function-parameters"
          }
        ]
      }
      {
        name: "meta.type.function.ts"
        begin: '''
          (?x)(
            (?=
              [(]\\s*(
                ([)]) |
                (\\.\\.\\.) |
                ([_$[:alnum:]]+\\s*(
                  ([:,?=])|
                  ([)]\\s*=>)
                ))
              )
            )
          )
        '''
        end: "(?<=\\))"
        patterns: [
          {
            include: "#function-parameters"
          }
        ]
      }
    ]
  "type-function-return-type":
    patterns: [
      {
        name: "meta.type.function.return.ts"
        begin: "(=>)(?=\\s*\\S)"
        beginCaptures:
          "1":
            name: "storage.type.function.arrow.ts"
        end: "(?<!=>)(?<![|&])(?=[,\\]\\)\\{\\}=;>]|//|$)"
        patterns: [
          {
            include: "#type-function-return-type-core"
          }
        ]
      }
      {
        name: "meta.type.function.return.ts"
        begin: "=>"
        beginCaptures:
          "0":
            name: "storage.type.function.arrow.ts"
        end: "(?<!=>)(?<![|&])((?=[,\\]\\)\\{\\}=;>]|//|^\\s*$)|((?<=\\S)(?=\\s*$)))"
        patterns: [
          {
            include: "#type-function-return-type-core"
          }
        ]
      }
    ]
  "type-function-return-type-core":
    patterns: [
      {
        include: "#comment"
      }
      {
        begin: "(?<==>)(?=\\s*\\{)"
        end: "(?<=\\})"
        patterns: [
          {
            include: "#type-object"
          }
        ]
      }
      {
        include: "#type-predicate-operator"
      }
      {
        include: "#type"
      }
    ]
  "type-operators":
    patterns: [
      {
        include: "#typeof-operator"
      }
      {
        begin: "([&|])(?=\\s*\\{)"
        beginCaptures:
          "0":
            name: "keyword.operator.type.ts"
        end: "(?<=\\})"
        patterns: [
          {
            include: "#type-object"
          }
        ]
      }
      {
        begin: "[&|]"
        beginCaptures:
          "0":
            name: "keyword.operator.type.ts"
        end: "(?=\\S)"
      }
      {
        name: "keyword.operator.expression.keyof.ts"
        match: "(?<!\\.|\\$)\\bkeyof\\b(?!\\$|\\.)"
      }
    ]
  "type-predicate-operator":
    name: "keyword.operator.expression.is.ts"
    match: "(?<!\\.|\\$)\\bis\\b(?!\\$|\\.)"
  "type-name":
    patterns: [
      {
        match: "([_$[:alpha:]][_$[:alnum:]]*)\\s*(\\.)"
        captures:
          "1":
            name: "entity.name.type.module.ts"
          "2":
            name: "punctuation.accessor.ts"
      }
      {
        name: "entity.name.type.ts"
        match: "[_$[:alpha:]][_$[:alnum:]]*"
      }
    ]
  "punctuation-comma":
    name: "punctuation.separator.comma.ts"
    match: ","
  "punctuation-semicolon":
    name: "punctuation.terminator.statement.ts"
    match: ";"
  "punctuation-accessor":
    name: "punctuation.accessor.ts"
    match: "\\."
  string:
    patterns: [
      {
        include: "#qstring-single"
      }
      {
        include: "#qstring-double"
      }
    ]
  "qstring-double":
    name: "string.quoted.double.ts"
    begin: "\""
    beginCaptures:
      "0":
        name: "punctuation.definition.string.begin.ts"
    end: "(\")|((?:[^\\\\\\n])$)"
    endCaptures:
      "1":
        name: "punctuation.definition.string.end.ts"
      "2":
        name: "invalid.illegal.newline.ts"
    patterns: [
      {
        include: "#string-character-escape"
      }
    ]
  "qstring-single":
    name: "string.quoted.single.ts"
    begin: "'"
    beginCaptures:
      "0":
        name: "punctuation.definition.string.begin.ts"
    end: "(\\')|((?:[^\\\\\\n])$)"
    endCaptures:
      "1":
        name: "punctuation.definition.string.end.ts"
      "2":
        name: "invalid.illegal.newline.ts"
    patterns: [
      {
        include: "#string-character-escape"
      }
    ]
  "string-character-escape":
    name: "constant.character.escape.ts"
    match: "\\\\(x[0-9A-Fa-f]{2}|[0-2][0-7]{0,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|.|$)"
  template:
    name: "string.template.ts"
    begin: "([_$[:alpha:]][_$[:alnum:]]*)?(`)"
    beginCaptures:
      "1":
        name: "entity.name.function.tagged-template.ts"
      "2":
        name: "punctuation.definition.string.template.begin.ts"
    end: "`"
    endCaptures:
      "0":
        name: "punctuation.definition.string.template.end.ts"
    patterns: [
      {
        include: "#template-substitution-element"
      }
      {
        include: "#string-character-escape"
      }
    ]
  "template-substitution-element":
    name: "meta.template.expression.ts"
    begin: "\\$\\{"
    beginCaptures:
      "0":
        name: "punctuation.definition.template-expression.begin.ts"
    end: "\\}"
    endCaptures:
      "0":
        name: "punctuation.definition.template-expression.end.ts"
    patterns: [
      {
        include: "#expression"
      }
    ]
    contentName: "meta.embedded.line.ts"
  regex:
    patterns: [
      {
        name: "string.regexp.ts"
        begin: "(?<=[=(:,\\[?+!]|return|case|=>|&&|\\|\\||\\*\\/)\\s*(\\/)(?![\\/*])(?=(?:[^\\/\\\\\\[]|\\\\.|\\[([^\\]\\\\]|\\\\.)+\\])+\\/(?![\\/*])[gimuy]*(?!\\s*[a-zA-Z0-9_$]))"
        beginCaptures:
          "1":
            name: "punctuation.definition.string.begin.ts"
        end: "(/)([gimuy]*)"
        endCaptures:
          "1":
            name: "punctuation.definition.string.end.ts"
          "2":
            name: "keyword.other.ts"
        patterns: [
          {
            include: "#regexp"
          }
        ]
      }
      {
        name: "string.regexp.ts"
        begin: "(?<![_$[:alnum:])])\\/(?![\\/*])(?=(?:[^\\/\\\\\\[]|\\\\.|\\[([^\\]\\\\]|\\\\.)+\\])+\\/(?![\\/*])[gimuy]*(?!\\s*[a-zA-Z0-9_$]))"
        beginCaptures:
          "0":
            name: "punctuation.definition.string.begin.ts"
        end: "(/)([gimuy]*)"
        endCaptures:
          "1":
            name: "punctuation.definition.string.end.ts"
          "2":
            name: "keyword.other.ts"
        patterns: [
          {
            include: "#regexp"
          }
        ]
      }
    ]
  regexp:
    patterns: [
      {
        name: "keyword.control.anchor.regexp"
        match: "\\\\[bB]|\\^|\\$"
      }
      {
        name: "keyword.other.back-reference.regexp"
        match: "\\\\[1-9]\\d*"
      }
      {
        name: "keyword.operator.quantifier.regexp"
        match: "[?+*]|\\{(\\d+,\\d+|\\d+,|,\\d+|\\d+)\\}\\??"
      }
      {
        name: "keyword.operator.or.regexp"
        match: "\\|"
      }
      {
        name: "meta.group.assertion.regexp"
        begin: "(\\()((\\?=)|(\\?!))"
        beginCaptures:
          "1":
            name: "punctuation.definition.group.regexp"
          "2":
            name: "punctuation.definition.group.assertion.regexp"
          "3":
            name: "meta.assertion.look-ahead.regexp"
          "4":
            name: "meta.assertion.negative-look-ahead.regexp"
        end: "(\\))"
        endCaptures:
          "1":
            name: "punctuation.definition.group.regexp"
        patterns: [
          {
            include: "#regexp"
          }
        ]
      }
      {
        name: "meta.group.regexp"
        begin: "\\((\\?:)?"
        beginCaptures:
          "0":
            name: "punctuation.definition.group.regexp"
          "1":
            name: "punctuation.definition.group.no-capture.regexp"
        end: "\\)"
        endCaptures:
          "0":
            name: "punctuation.definition.group.regexp"
        patterns: [
          {
            include: "#regexp"
          }
        ]
      }
      {
        name: "constant.other.character-class.set.regexp"
        begin: "(\\[)(\\^)?"
        beginCaptures:
          "1":
            name: "punctuation.definition.character-class.regexp"
          "2":
            name: "keyword.operator.negation.regexp"
        end: "(\\])"
        endCaptures:
          "1":
            name: "punctuation.definition.character-class.regexp"
        patterns: [
          {
            name: "constant.other.character-class.range.regexp"
            match: "(?:.|(\\\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\\\c[A-Z])|(\\\\.))\\-(?:[^\\]\\\\]|(\\\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\\\c[A-Z])|(\\\\.))"
            captures:
              "1":
                name: "constant.character.numeric.regexp"
              "2":
                name: "constant.character.control.regexp"
              "3":
                name: "constant.character.escape.backslash.regexp"
              "4":
                name: "constant.character.numeric.regexp"
              "5":
                name: "constant.character.control.regexp"
              "6":
                name: "constant.character.escape.backslash.regexp"
          }
          {
            include: "#regex-character-class"
          }
        ]
      }
      {
        include: "#regex-character-class"
      }
    ]
  "regex-character-class":
    patterns: [
      {
        name: "constant.other.character-class.regexp"
        match: "\\\\[wWsSdDtrnvf]|\\."
      }
      {
        name: "constant.character.numeric.regexp"
        match: "\\\\([0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4})"
      }
      {
        name: "constant.character.control.regexp"
        match: "\\\\c[A-Z]"
      }
      {
        name: "constant.character.escape.backslash.regexp"
        match: "\\\\."
      }
    ]
  comment:
    patterns: [
      {
        name: "comment.block.documentation.ts"
        begin: "/\\*\\*(?!/)"
        beginCaptures:
          "0":
            name: "punctuation.definition.comment.ts"
        end: "\\*/"
        endCaptures:
          "0":
            name: "punctuation.definition.comment.ts"
        patterns: [
          {
            include: "#docblock"
          }
        ]
      }
      {
        name: "comment.block.ts"
        begin: "(/\\*)(?:\\s*((@)internal)(?=\\s|(\\*/)))?"
        beginCaptures:
          "1":
            name: "punctuation.definition.comment.ts"
          "2":
            name: "storage.type.internaldeclaration.ts"
          "3":
            name: "punctuation.decorator.internaldeclaration.ts"
        end: "\\*/"
        endCaptures:
          "0":
            name: "punctuation.definition.comment.ts"
      }
      {
        begin: "(^[ \\t]+)?((//)(?:\\s*((@)internal)(?=\\s|$))?)"
        beginCaptures:
          "1":
            name: "punctuation.whitespace.comment.leading.ts"
          "2":
            name: "comment.line.double-slash.ts"
          "3":
            name: "punctuation.definition.comment.ts"
          "4":
            name: "storage.type.internaldeclaration.ts"
          "5":
            name: "punctuation.decorator.internaldeclaration.ts"
        end: "(?=^)"
        contentName: "comment.line.double-slash.ts"
      }
    ]
  directives:
    name: "comment.line.triple-slash.directive.ts"
    begin: "^(///)\\s*(?=<(reference|amd-dependency|amd-module)(\\s+(path|types|no-default-lib|name)\\s*=\\s*((\\'([^\\'\\\\]|\\\\\\'|\\\\)*\\')|(\\\"([^\\\"\\\\]|\\\\\\\"|\\\\)*\\\")))+\\s*/>\\s*$)"
    beginCaptures:
      "1":
        name: "punctuation.definition.comment.ts"
    end: "(?=^)"
    patterns: [
      {
        name: "meta.tag.ts"
        begin: "(<)(reference|amd-dependency|amd-module)"
        beginCaptures:
          "1":
            name: "punctuation.definition.tag.directive.ts"
          "2":
            name: "entity.name.tag.directive.ts"
        end: "/>"
        endCaptures:
          "0":
            name: "punctuation.definition.tag.directive.ts"
        patterns: [
          {
            name: "entity.other.attribute-name.directive.ts"
            match: "path|types|no-default-lib|name"
          }
          {
            name: "keyword.operator.assignment.ts"
            match: "="
          }
          {
            include: "#string"
          }
        ]
      }
    ]
  docblock:
    patterns: [
      {
        match: '''
          (?x)
          ((@)(?:access|api))
          \\s+
          (private|protected|public)
          \\b
        '''
        captures:
          "1":
            name: "storage.type.class.jsdoc"
          "2":
            name: "punctuation.definition.block.tag.jsdoc"
          "3":
            name: "constant.language.access-type.jsdoc"
      }
      {
        match: '''
          (?x)
          ((@)author)
          \\s+
          (
            [^@\\s<>*/]
            (?:[^@<>*/]|\\*[^/])*
          )
          (?:
            \\s*
            (<)
            ([^>\\s]+)
            (>)
          )?
        '''
        captures:
          "1":
            name: "storage.type.class.jsdoc"
          "2":
            name: "punctuation.definition.block.tag.jsdoc"
          "3":
            name: "entity.name.type.instance.jsdoc"
          "4":
            name: "punctuation.definition.bracket.angle.begin.jsdoc"
          "5":
            name: "constant.other.email.link.underline.jsdoc"
          "6":
            name: "punctuation.definition.bracket.angle.end.jsdoc"
      }
      {
        match: '''
          (?x)
          ((@)borrows) \\s+
          ((?:[^@\\s*/]|\\*[^/])+)    # <that namepath>
          \\s+ (as) \\s+              # as
          ((?:[^@\\s*/]|\\*[^/])+)    # <this namepath>
        '''
        captures:
          "1":
            name: "storage.type.class.jsdoc"
          "2":
            name: "punctuation.definition.block.tag.jsdoc"
          "3":
            name: "entity.name.type.instance.jsdoc"
          "4":
            name: "keyword.operator.control.jsdoc"
          "5":
            name: "entity.name.type.instance.jsdoc"
      }
      {
        name: "meta.example.jsdoc"
        begin: "((@)example)\\s+"
        end: "(?=@|\\*/)"
        beginCaptures:
          "1":
            name: "storage.type.class.jsdoc"
          "2":
            name: "punctuation.definition.block.tag.jsdoc"
        patterns: [
          {
            match: "^\\s\\*\\s+"
          }
          {
            contentName: "constant.other.description.jsdoc"
            begin: "\\G(<)caption(>)"
            beginCaptures:
              "0":
                name: "entity.name.tag.inline.jsdoc"
              "1":
                name: "punctuation.definition.bracket.angle.begin.jsdoc"
              "2":
                name: "punctuation.definition.bracket.angle.end.jsdoc"
            end: "(</)caption(>)|(?=\\*/)"
            endCaptures:
              "0":
                name: "entity.name.tag.inline.jsdoc"
              "1":
                name: "punctuation.definition.bracket.angle.begin.jsdoc"
              "2":
                name: "punctuation.definition.bracket.angle.end.jsdoc"
          }
          {
            match: "[^\\s@*](?:[^*]|\\*[^/])*"
            captures:
              "0":
                name: "source.embedded.ts"
          }
        ]
      }
      {
        match: "(?x) ((@)kind) \\s+ (class|constant|event|external|file|function|member|mixin|module|namespace|typedef) \\b"
        captures:
          "1":
            name: "storage.type.class.jsdoc"
          "2":
            name: "punctuation.definition.block.tag.jsdoc"
          "3":
            name: "constant.language.symbol-type.jsdoc"
      }
      {
        match: '''
          (?x)
          ((@)see)
          \\s+
          (?:
            # URL
            (
              (?=https?://)
              (?:[^\\s*]|\\*[^/])+
            )
            |
            # JSDoc namepath
            (
              (?!
                # Avoid matching bare URIs (also acceptable as links)
                https?://
                |
                # Avoid matching {@inline tags}; we match those below
                (?:\\[[^\\[\\]]*\\])? # Possible description [preceding]{@tag}
                {@(?:link|linkcode|linkplain|tutorial)\\b
              )
              # Matched namepath
              (?:[^@\\s*/]|\\*[^/])+
            )
          )
        '''
        captures:
          "1":
            name: "storage.type.class.jsdoc"
          "2":
            name: "punctuation.definition.block.tag.jsdoc"
          "3":
            name: "variable.other.link.underline.jsdoc"
          "4":
            name: "entity.name.type.instance.jsdoc"
      }
      {
        match: '''
          (?x)
          ((@)template)
          \\s+
          # One or more valid identifiers
          (
            [A-Za-z_$]         # First character: non-numeric word character
            [\\w$.\\[\\]]*        # Rest of identifier
            (?:                # Possible list of additional identifiers
              \\s* , \\s*
              [A-Za-z_$]
              [\\w$.\\[\\]]*
            )*
          )
        '''
        captures:
          "1":
            name: "storage.type.class.jsdoc"
          "2":
            name: "punctuation.definition.block.tag.jsdoc"
          "3":
            name: "variable.other.jsdoc"
      }
      {
        match: '''
          (?x)
          (
            (@)
            (?:arg|argument|const|constant|member|namespace|param|var)
          )
          \\s+
          (
            [A-Za-z_$]
            [\\w$.\\[\\]]*
          )
        '''
        captures:
          "1":
            name: "storage.type.class.jsdoc"
          "2":
            name: "punctuation.definition.block.tag.jsdoc"
          "3":
            name: "variable.other.jsdoc"
      }
      {
        begin: "((@)typedef)\\s+(?={)"
        beginCaptures:
          "1":
            name: "storage.type.class.jsdoc"
          "2":
            name: "punctuation.definition.block.tag.jsdoc"
        end: "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])"
        patterns: [
          {
            include: "#jsdoctype"
          }
          {
            name: "entity.name.type.instance.jsdoc"
            match: "(?:[^@\\s*/]|\\*[^/])+"
          }
        ]
      }
      {
        begin: "((@)(?:arg|argument|const|constant|member|namespace|param|prop|property|var))\\s+(?={)"
        beginCaptures:
          "1":
            name: "storage.type.class.jsdoc"
          "2":
            name: "punctuation.definition.block.tag.jsdoc"
        end: "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])"
        patterns: [
          {
            include: "#jsdoctype"
          }
          {
            name: "variable.other.jsdoc"
            match: "([A-Za-z_$][\\w$.\\[\\]]*)"
          }
          {
            name: "variable.other.jsdoc"
            match: '''
              (?x)
              (\\[)\\s*
              [\\w$]+
              (?:
                (?:\\[\\])?                                        # Foo[ ].bar properties within an array
                \\.                                                # Foo.Bar namespaced parameter
                [\\w$]+
              )*
              (?:
                \\s*
                (=)                                                # [foo=bar] Default parameter value
                \\s*
                (
                  # The inner regexes are to stop the match early at */ and to not stop at escaped quotes
                  (?>
                    "(?:(?:\\*(?!/))|(?:\\\\(?!"))|[^*\\\\])*?" |                      # [foo="bar"] Double-quoted
                    '(?:(?:\\*(?!/))|(?:\\\\(?!'))|[^*\\\\])*?' |                      # [foo='bar'] Single-quoted
                    \\[ (?:(?:\\*(?!/))|[^*])*? \\] |                                # [foo=[1,2]] Array literal
                    (?:(?:\\*(?!/))|\\s(?!\\s*\\])|\\[.*?(?:\\]|(?=\\*/))|[^*\\s\\[\\]])*   # Everything else
                  )*
                )
              )?
              \\s*(?:(\\])((?:[^*\\s]|\\*[^\\s/])+)?|(?=\\*/))
            '''
            captures:
              "1":
                name: "punctuation.definition.optional-value.begin.bracket.square.jsdoc"
              "2":
                name: "keyword.operator.assignment.jsdoc"
              "3":
                name: "source.embedded.ts"
              "4":
                name: "punctuation.definition.optional-value.end.bracket.square.jsdoc"
              "5":
                name: "invalid.illegal.syntax.jsdoc"
          }
        ]
      }
      {
        begin: '''
          (?x)
          (
            (@)
            (?:define|enum|exception|export|extends|lends|implements|modifies
            |namespace|private|protected|returns?|suppress|this|throws|type
            |yields?)
          )
          \\s+(?={)
        '''
        beginCaptures:
          "1":
            name: "storage.type.class.jsdoc"
          "2":
            name: "punctuation.definition.block.tag.jsdoc"
        end: "(?=\\s|\\*/|[^{}\\[\\]A-Za-z_$])"
        patterns: [
          {
            include: "#jsdoctype"
          }
        ]
      }
      {
        match: '''
          (?x)
          (
            (@)
            (?:alias|augments|callback|constructs|emits|event|fires|exports?
            |extends|external|function|func|host|lends|listens|interface|memberof!?
            |method|module|mixes|mixin|name|requires|see|this|typedef|uses)
          )
          \\s+
          (
            (?:
              [^{}@\\s*] | \\*[^/]
            )+
          )
        '''
        captures:
          "1":
            name: "storage.type.class.jsdoc"
          "2":
            name: "punctuation.definition.block.tag.jsdoc"
          "3":
            name: "entity.name.type.instance.jsdoc"
      }
      {
        contentName: "variable.other.jsdoc"
        begin: "((@)(?:default(?:value)?|license|version))\\s+(([''\"]))"
        beginCaptures:
          "1":
            name: "storage.type.class.jsdoc"
          "2":
            name: "punctuation.definition.block.tag.jsdoc"
          "3":
            name: "variable.other.jsdoc"
          "4":
            name: "punctuation.definition.string.begin.jsdoc"
        end: "(\\3)|(?=$|\\*/)"
        endCaptures:
          "0":
            name: "variable.other.jsdoc"
          "1":
            name: "punctuation.definition.string.end.jsdoc"
      }
      {
        match: "((@)(?:default(?:value)?|license|tutorial|variation|version))\\s+([^\\s*]+)"
        captures:
          "1":
            name: "storage.type.class.jsdoc"
          "2":
            name: "punctuation.definition.block.tag.jsdoc"
          "3":
            name: "variable.other.jsdoc"
      }
      {
        name: "storage.type.class.jsdoc"
        match: "(?x) (@) (?:abstract|access|alias|api|arg|argument|async|attribute|augments|author|beta|borrows|bubbles |callback|chainable|class|classdesc|code|config|const|constant|constructor|constructs|copyright |default|defaultvalue|define|deprecated|desc|description|dict|emits|enum|event|example|exception |exports?|extends|extension(?:_?for)?|external|externs|file|fileoverview|final|fires|for|func |function|generator|global|hideconstructor|host|ignore|implements|implicitCast|inherit[Dd]oc |inner|instance|interface|internal|kind|lends|license|listens|main|member|memberof!?|method |mixes|mixins?|modifies|module|name|namespace|noalias|nocollapse|nocompile|nosideeffects |override|overview|package|param|polymer(?:Behavior)?|preserve|private|prop|property|protected |public|read[Oo]nly|record|require[ds]|returns?|see|since|static|struct|submodule|summary |suppress|template|this|throws|todo|tutorial|type|typedef|unrestricted|uses|var|variation |version|virtual|writeOnce|yields?) \\b"
        captures:
          "1":
            name: "punctuation.definition.block.tag.jsdoc"
      }
      {
        include: "#inline-tags"
      }
    ]
  brackets:
    patterns: [
      {
        begin: "{"
        end: "}|(?=\\*/)"
        patterns: [
          {
            include: "#brackets"
          }
        ]
      }
      {
        begin: "\\["
        end: "\\]|(?=\\*/)"
        patterns: [
          {
            include: "#brackets"
          }
        ]
      }
    ]
  "inline-tags":
    patterns: [
      {
        name: "constant.other.description.jsdoc"
        match: "(\\[)[^\\]]+(\\])(?={@(?:link|linkcode|linkplain|tutorial))"
        captures:
          "1":
            name: "punctuation.definition.bracket.square.begin.jsdoc"
          "2":
            name: "punctuation.definition.bracket.square.end.jsdoc"
      }
      {
        name: "entity.name.type.instance.jsdoc"
        begin: "({)((@)(?:link(?:code|plain)?|tutorial))\\s*"
        beginCaptures:
          "1":
            name: "punctuation.definition.bracket.curly.begin.jsdoc"
          "2":
            name: "storage.type.class.jsdoc"
          "3":
            name: "punctuation.definition.inline.tag.jsdoc"
        end: "}|(?=\\*/)"
        endCaptures:
          "0":
            name: "punctuation.definition.bracket.curly.end.jsdoc"
        patterns: [
          {
            match: "\\G((?=https?://)(?:[^|}\\s*]|\\*[/])+)(\\|)?"
            captures:
              "1":
                name: "variable.other.link.underline.jsdoc"
              "2":
                name: "punctuation.separator.pipe.jsdoc"
          }
          {
            match: "\\G((?:[^{}@\\s|*]|\\*[^/])+)(\\|)?"
            captures:
              "1":
                name: "variable.other.description.jsdoc"
              "2":
                name: "punctuation.separator.pipe.jsdoc"
          }
        ]
      }
    ]
  jsdoctype:
    patterns: [
      {
        name: "invalid.illegal.type.jsdoc"
        match: "\\G{(?:[^}*]|\\*[^/}])+$"
      }
      {
        contentName: "entity.name.type.instance.jsdoc"
        begin: "\\G({)"
        beginCaptures:
          "0":
            name: "entity.name.type.instance.jsdoc"
          "1":
            name: "punctuation.definition.bracket.curly.begin.jsdoc"
        end: "((}))\\s*|(?=\\*/)"
        endCaptures:
          "1":
            name: "entity.name.type.instance.jsdoc"
          "2":
            name: "punctuation.definition.bracket.curly.end.jsdoc"
        patterns: [
          {
            include: "#brackets"
          }
        ]
      }
    ]